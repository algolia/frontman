# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rubocop/all/rubocop.rbi
#
# rubocop-0.71.0

module RuboCop
end
module RuboCop::Version
  def self.version(debug = nil); end
end
class String
  def blank?; end
  def strip_indent; end
end
module RuboCop::PathUtil
  def absolute?(path); end
  def hidden_dir?(path); end
  def hidden_file_in_not_hidden_dir?(pattern, path); end
  def match_path?(pattern, path); end
  def relative_path(path, base_dir = nil); end
  def self.absolute?(path); end
  def self.chdir(dir, &block); end
  def self.hidden_dir?(path); end
  def self.hidden_file_in_not_hidden_dir?(pattern, path); end
  def self.match_path?(pattern, path); end
  def self.pwd; end
  def self.relative_path(path, base_dir = nil); end
  def self.reset_pwd; end
  def self.smart_path(path); end
  def smart_path(path); end
end
module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir); end
  def find_files_upwards(filename, start_dir); end
  def self.root_level=(level); end
  def self.root_level?(path); end
  def traverse_files_upwards(filename, start_dir); end
end
module RuboCop::Platform
  def self.windows?; end
end
module RuboCop::StringUtil
  def self.similarity(string_a, string_b); end
  def similarity(string_a, string_b); end
end
module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
end
class RuboCop::NodePattern
  def ==(other); end
  def eql?(other); end
  def initialize(str); end
  def marshal_dump; end
  def marshal_load(pattern); end
  def match(*args); end
  def pattern; end
  def to_s; end
end
class RuboCop::NodePattern::Invalid < StandardError
end
class RuboCop::NodePattern::Compiler
  def auto_use_temp_node?(code); end
  def captures; end
  def compile_any_order(capture_all = nil); end
  def compile_arg(token); end
  def compile_args(tokens); end
  def compile_ascend; end
  def compile_capture; end
  def compile_captured_ellipsis; end
  def compile_ellipsis; end
  def compile_expr(token = nil); end
  def compile_funcall(method); end
  def compile_guard_clause; end
  def compile_intersect; end
  def compile_literal(literal); end
  def compile_negation; end
  def compile_nodetype(type); end
  def compile_param(number); end
  def compile_predicate(predicate); end
  def compile_repeated_expr(token); end
  def compile_seq; end
  def compile_union; end
  def compile_wildcard(name); end
  def emit_method_code; end
  def emit_param_list; end
  def emit_retval; end
  def emit_trailing_params; end
  def emit_yield_capture(when_no_capture = nil); end
  def fail_due_to(message); end
  def get_param(number); end
  def initialize(str, node_var = nil); end
  def insure_same_captures(enum, what); end
  def match_code; end
  def next_capture; end
  def next_temp_value; end
  def next_temp_variable(name); end
  def parse_repetition_token; end
  def repeated_generator(expr, captured, accumulate); end
  def run(node_var); end
  def self.tokens(pattern); end
  def substitute_cur_node(code, cur_node, first_cur_node: nil); end
  def tokens; end
  def tokens_until(stop, what); end
  def variadic_seq_term; end
  def with_child_context(code, child_index); end
  def with_context(code, cur_node, use_temp_node: nil); end
  def with_seq_head_context(code); end
  def with_temp_node(cur_node); end
  def with_temp_variables(&block); end
end
class RuboCop::NodePattern::Compiler::Sequence < SimpleDelegator
  def compile; end
  def compile_child_nb_guard; end
  def compile_first_terms; end
  def compile_last_terms; end
  def compile_seq_head; end
  def compile_terms(index_range, start); end
  def compile_variadic_term; end
  def first_terms_arity; end
  def first_terms_range; end
  def initialize(compiler, *arity_term_list); end
  def last_terms_arity; end
  def last_terms_range; end
  def seq_head?; end
  def term(index, range); end
  def variadic_arity; end
  def variadic_term_min_arity; end
end
module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end
  def def_node_search(method_name, pattern_str); end
  def node_search(method_name, compiler, on_match, prelude, called_from); end
  def node_search_all(method_name, compiler, called_from); end
  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end
  def node_search_first(method_name, compiler, called_from); end
end
class RuboCop::StringInterpreter
  def self.interpret(string); end
  def self.interpret_hex(escape); end
  def self.interpret_octal(escape); end
  def self.interpret_string_escape(escape); end
  def self.interpret_unicode(escape); end
end
module RuboCop::AST
end
module RuboCop::AST::Sexp
  def s(type, *children); end
end
class RuboCop::AST::Node < Parser::AST::Node
  def __ENCODING___type?; end
  def __FILE___type?; end
  def __LINE___type?; end
  def alias_type?; end
  def ancestors; end
  def and_asgn_type?; end
  def and_type?; end
  def arg_expr_type?; end
  def arg_type?; end
  def args_type?; end
  def argument?; end
  def array_pattern_type?; end
  def array_pattern_with_tail_type?; end
  def array_type?; end
  def asgn_rhs(node = nil); end
  def assignment?; end
  def assignment_or_similar?(node = nil); end
  def back_ref_type?; end
  def basic_conditional?; end
  def basic_literal?; end
  def begin_type?; end
  def begin_value_used?; end
  def block_pass_type?; end
  def block_type?; end
  def blockarg_expr_type?; end
  def blockarg_type?; end
  def break_type?; end
  def call_type?; end
  def case_if_value_used?; end
  def case_match_type?; end
  def case_type?; end
  def casgn_type?; end
  def cbase_type?; end
  def chained?; end
  def child_nodes; end
  def class_constructor?(node = nil); end
  def class_type?; end
  def complete!; end
  def complete?; end
  def complex_type?; end
  def conditional?; end
  def const_name; end
  def const_pattern_type?; end
  def const_type?; end
  def csend_type?; end
  def cvar_type?; end
  def cvasgn_type?; end
  def def_type?; end
  def defined_module0(node = nil); end
  def defined_module; end
  def defined_module_name; end
  def defined_type?; end
  def defs_type?; end
  def descendants; end
  def dstr_type?; end
  def dsym_type?; end
  def each_ancestor(*types, &block); end
  def each_child_node(*types); end
  def each_descendant(*types, &block); end
  def each_node(*types, &block); end
  def eflipflop_type?; end
  def empty_else_type?; end
  def empty_source?; end
  def ensure_type?; end
  def equals_asgn?; end
  def erange_type?; end
  def false_type?; end
  def falsey_literal?; end
  def find_pattern_type?; end
  def first_line; end
  def float_type?; end
  def for_type?; end
  def for_value_used?; end
  def forward_arg_type?; end
  def forward_args_type?; end
  def forwarded_args_type?; end
  def guard_clause?(node = nil); end
  def gvar_type?; end
  def gvasgn_type?; end
  def hash_pattern_type?; end
  def hash_type?; end
  def ident_type?; end
  def if_guard_type?; end
  def if_type?; end
  def iflipflop_type?; end
  def immutable_literal?; end
  def in_match_type?; end
  def in_pattern_type?; end
  def index_type?; end
  def indexasgn_type?; end
  def initialize(type, children = nil, properties = nil); end
  def int_type?; end
  def irange_type?; end
  def ivar_type?; end
  def ivasgn_type?; end
  def keyword?; end
  def kwarg_type?; end
  def kwbegin_type?; end
  def kwnilarg_type?; end
  def kwoptarg_type?; end
  def kwrestarg_type?; end
  def kwsplat_type?; end
  def lambda?(node = nil); end
  def lambda_or_proc?(node = nil); end
  def lambda_type?; end
  def last_line; end
  def line_count; end
  def literal?; end
  def lvar_type?; end
  def lvasgn_type?; end
  def masgn_type?; end
  def match_alt_type?; end
  def match_as_type?; end
  def match_current_line_type?; end
  def match_nil_pattern_type?; end
  def match_rest_type?; end
  def match_var_type?; end
  def match_with_lvasgn_type?; end
  def match_with_trailing_comma_type?; end
  def mlhs_type?; end
  def module_definition?(node = nil); end
  def module_type?; end
  def multiline?; end
  def mutable_literal?; end
  def new_class_or_module_block?(node = nil); end
  def next_type?; end
  def nil_type?; end
  def node_parts; end
  def nonempty_line_count; end
  def not_type?; end
  def nth_ref_type?; end
  def numargs_type?; end
  def numblock_type?; end
  def numeric_type?; end
  def objc_kwarg_type?; end
  def objc_restarg_type?; end
  def objc_varargs_type?; end
  def op_asgn_type?; end
  def operator_keyword?; end
  def optarg_type?; end
  def or_asgn_type?; end
  def or_type?; end
  def pair_type?; end
  def parent; end
  def parent=(node); end
  def parent_module_name; end
  def parent_module_name_for_block(ancestor); end
  def parent_module_name_for_sclass(sclass_node); end
  def parent_module_name_part(node); end
  def parenthesized_call?; end
  def pin_type?; end
  def postexe_type?; end
  def preexe_type?; end
  def proc?(node = nil); end
  def procarg0_type?; end
  def pure?; end
  def range_type?; end
  def rational_type?; end
  def receiver(node = nil); end
  def recursive_basic_literal?; end
  def recursive_literal?; end
  def redo_type?; end
  def reference?; end
  def regexp_type?; end
  def regopt_type?; end
  def resbody_type?; end
  def rescue_type?; end
  def restarg_expr_type?; end
  def restarg_type?; end
  def retry_type?; end
  def return_type?; end
  def sclass_type?; end
  def self_type?; end
  def send_type?; end
  def shadowarg_type?; end
  def shorthand_asgn?; end
  def sibling_index; end
  def single_line?; end
  def source; end
  def source_length; end
  def source_range; end
  def special_keyword?; end
  def splat_type?; end
  def str_content(node = nil); end
  def str_type?; end
  def super_type?; end
  def sym_type?; end
  def true_type?; end
  def truthy_literal?; end
  def undef_type?; end
  def unless_guard_type?; end
  def until_post_type?; end
  def until_type?; end
  def updated(type = nil, children = nil, properties = nil); end
  def value_used?; end
  def variable?; end
  def visit_ancestors(types); end
  def visit_descendants(types, &block); end
  def when_type?; end
  def while_post_type?; end
  def while_type?; end
  def while_until_value_used?; end
  def xstr_type?; end
  def yield_type?; end
  def zsuper_type?; end
  extend RuboCop::NodePattern::Macros
  include RuboCop::AST::Sexp
end
module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?; end
  def bang_method?; end
  def camel_case_method?; end
  def comparison_method?; end
  def const_receiver?; end
  def enumerator_method?; end
  def method?(name); end
  def negation_method?; end
  def operator_method?; end
  def predicate_method?; end
  def prefix_bang?; end
  def prefix_not?; end
  def self_receiver?; end
end
module RuboCop::AST::BinaryOperatorNode
  def conditions; end
  def lhs; end
  def rhs; end
end
module RuboCop::AST::CollectionNode
  def &(*args, &block); end
  def *(*args, &block); end
  def +(*args, &block); end
  def -(*args, &block); end
  def <<(*args, &block); end
  def [](*args, &block); end
  def []=(*args, &block); end
  def all?(*args, &block); end
  def any?(*args, &block); end
  def append(*args, &block); end
  def assoc(*args, &block); end
  def at(*args, &block); end
  def bsearch(*args, &block); end
  def bsearch_index(*args, &block); end
  def chain(*args, &block); end
  def chunk(*args, &block); end
  def chunk_while(*args, &block); end
  def clear(*args, &block); end
  def collect!(*args, &block); end
  def collect(*args, &block); end
  def collect_concat(*args, &block); end
  def combination(*args, &block); end
  def compact!(*args, &block); end
  def compact(*args, &block); end
  def concat(*args, &block); end
  def count(*args, &block); end
  def cycle(*args, &block); end
  def delete(*args, &block); end
  def delete_at(*args, &block); end
  def delete_if(*args, &block); end
  def detect(*args, &block); end
  def difference(*args, &block); end
  def dig(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def each(*args, &block); end
  def each_cons(*args, &block); end
  def each_entry(*args, &block); end
  def each_index(*args, &block); end
  def each_slice(*args, &block); end
  def each_with_index(*args, &block); end
  def each_with_object(*args, &block); end
  def empty?(*args, &block); end
  def entries(*args, &block); end
  def fetch(*args, &block); end
  def fill(*args, &block); end
  def filter!(*args, &block); end
  def filter(*args, &block); end
  def find(*args, &block); end
  def find_all(*args, &block); end
  def find_index(*args, &block); end
  def first(*args, &block); end
  def flat_map(*args, &block); end
  def flatten!(*args, &block); end
  def flatten(*args, &block); end
  def grep(*args, &block); end
  def grep_v(*args, &block); end
  def group_by(*args, &block); end
  def include?(*args, &block); end
  def index(*args, &block); end
  def inject(*args, &block); end
  def insert(*args, &block); end
  def join(*args, &block); end
  def keep_if(*args, &block); end
  def last(*args, &block); end
  def lazy(*args, &block); end
  def length(*args, &block); end
  def map!(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def max_by(*args, &block); end
  def member?(*args, &block); end
  def min(*args, &block); end
  def min_by(*args, &block); end
  def minmax(*args, &block); end
  def minmax_by(*args, &block); end
  def none?(*args, &block); end
  def one?(*args, &block); end
  def pack(*args, &block); end
  def partition(*args, &block); end
  def permutation(*args, &block); end
  def pop(*args, &block); end
  def prepend(*args, &block); end
  def product(*args, &block); end
  def push(*args, &block); end
  def rassoc(*args, &block); end
  def reduce(*args, &block); end
  def reject!(*args, &block); end
  def reject(*args, &block); end
  def repeated_combination(*args, &block); end
  def repeated_permutation(*args, &block); end
  def replace(*args, &block); end
  def reverse!(*args, &block); end
  def reverse(*args, &block); end
  def reverse_each(*args, &block); end
  def rindex(*args, &block); end
  def rotate!(*args, &block); end
  def rotate(*args, &block); end
  def sample(*args, &block); end
  def select!(*args, &block); end
  def select(*args, &block); end
  def shelljoin(*args, &block); end
  def shift(*args, &block); end
  def shuffle!(*args, &block); end
  def shuffle(*args, &block); end
  def size(*args, &block); end
  def slice!(*args, &block); end
  def slice(*args, &block); end
  def slice_after(*args, &block); end
  def slice_before(*args, &block); end
  def slice_when(*args, &block); end
  def sort!(*args, &block); end
  def sort(*args, &block); end
  def sort_by!(*args, &block); end
  def sort_by(*args, &block); end
  def sum(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def to_ary(*args, &block); end
  def to_h(*args, &block); end
  def to_set(*args, &block); end
  def transpose(*args, &block); end
  def union(*args, &block); end
  def uniq!(*args, &block); end
  def uniq(*args, &block); end
  def unshift(*args, &block); end
  def values_at(*args, &block); end
  def zip(*args, &block); end
  def |(*args, &block); end
  extend Forwardable
end
module RuboCop::AST::ConditionalNode
  def body; end
  def condition; end
  def multiline_condition?; end
  def single_line_condition?; end
end
module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end
  def key; end
  def key_delta(other, alignment = nil); end
  def same_line?(other); end
  def value; end
  def value_delta(other); end
end
class RuboCop::AST::HashElementNode::HashElementDelta
  def delimiter_delta; end
  def delta(first, second, alignment = nil); end
  def first; end
  def initialize(first, second); end
  def key_delta(alignment = nil); end
  def keyword_splat?; end
  def second; end
  def valid_argument_types?; end
  def value_delta; end
end
module RuboCop::AST::MethodDispatchNode
  def access_modifier?; end
  def adjacent_def_modifier?(node = nil); end
  def arguments; end
  def arithmetic_operation?; end
  def assignment?; end
  def bare_access_modifier?; end
  def bare_access_modifier_declaration?(node = nil); end
  def binary_operation?; end
  def block_literal?; end
  def block_node; end
  def command?(name); end
  def const_receiver?; end
  def def_modifier?; end
  def dot?; end
  def double_colon?; end
  def implicit_call?; end
  def lambda?; end
  def lambda_literal?; end
  def macro?; end
  def macro_kwbegin_wrapper?(parent); end
  def macro_scope?(node = nil); end
  def method_name; end
  def non_bare_access_modifier?; end
  def non_bare_access_modifier_declaration?(node = nil); end
  def receiver; end
  def root_node?(node); end
  def self_receiver?; end
  def setter_method?; end
  def special_modifier?; end
  def unary_operation?; end
  extend RuboCop::NodePattern::Macros
  include RuboCop::AST::MethodIdentifierPredicates
end
module RuboCop::AST::ModifierNode
  def modifier_form?; end
end
module RuboCop::AST::ParameterizedNode
  def arguments?; end
  def block_argument?; end
  def first_argument; end
  def last_argument; end
  def parenthesized?; end
  def rest_argument?; end
  def splat_argument?; end
end
module RuboCop::AST::PredicateOperatorNode
  def logical_operator?; end
  def operator; end
  def semantic_operator?; end
end
module RuboCop::AST::BasicLiteralNode
  def value; end
end
class RuboCop::AST::AliasNode < RuboCop::AST::Node
  def new_identifier; end
  def old_identifier; end
end
class RuboCop::AST::AndNode < RuboCop::AST::Node
  def alternate_operator; end
  def inverse_operator; end
  include RuboCop::AST::BinaryOperatorNode
  include RuboCop::AST::PredicateOperatorNode
end
class RuboCop::AST::ArgsNode < RuboCop::AST::Node
  def empty_and_without_delimiters?; end
  include RuboCop::AST::CollectionNode
end
class RuboCop::AST::ArrayNode < RuboCop::AST::Node
  def bracketed?; end
  def percent_literal?(type = nil); end
  def square_brackets?; end
  def values; end
end
class RuboCop::AST::BlockNode < RuboCop::AST::Node
  def arguments; end
  def arguments?; end
  def body; end
  def braces?; end
  def closing_delimiter; end
  def delimiters; end
  def keywords?; end
  def lambda?; end
  def method_name; end
  def multiline?; end
  def opening_delimiter; end
  def send_node; end
  def single_line?; end
  def void_context?; end
end
class RuboCop::AST::BreakNode < RuboCop::AST::Node
  def arguments; end
  include RuboCop::AST::MethodDispatchNode
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::CaseNode < RuboCop::AST::Node
  def each_when; end
  def else?; end
  def else_branch; end
  def keyword; end
  def when_branches; end
  include RuboCop::AST::ConditionalNode
end
class RuboCop::AST::ClassNode < RuboCop::AST::Node
  def body; end
  def identifier; end
  def parent_class; end
end
class RuboCop::AST::DefNode < RuboCop::AST::Node
  def arguments; end
  def body; end
  def method_name; end
  def node_parts; end
  def receiver; end
  def void_context?; end
  include RuboCop::AST::MethodIdentifierPredicates
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::DefinedNode < RuboCop::AST::Node
  def node_parts; end
  include RuboCop::AST::MethodDispatchNode
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::EnsureNode < RuboCop::AST::Node
  def body; end
end
class RuboCop::AST::ForNode < RuboCop::AST::Node
  def body; end
  def collection; end
  def do?; end
  def keyword; end
  def variable; end
  def void_context?; end
end
class RuboCop::AST::HashNode < RuboCop::AST::Node
  def braces?; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def keys; end
  def mixed_delimiters?; end
  def pairs; end
  def pairs_on_same_line?; end
  def values; end
end
class RuboCop::AST::IfNode < RuboCop::AST::Node
  def branches; end
  def each_branch; end
  def else?; end
  def else_branch; end
  def elsif?; end
  def elsif_conditional?; end
  def if?; end
  def if_branch; end
  def inverse_keyword; end
  def keyword; end
  def modifier_form?; end
  def nested_conditional?; end
  def node_parts; end
  def ternary?; end
  def unless?; end
  include RuboCop::AST::ConditionalNode
  include RuboCop::AST::ModifierNode
end
class RuboCop::AST::KeywordSplatNode < RuboCop::AST::Node
  def colon?; end
  def hash_rocket?; end
  def node_parts; end
  def operator; end
  include RuboCop::AST::HashElementNode
end
class RuboCop::AST::ModuleNode < RuboCop::AST::Node
  def body; end
  def identifier; end
end
class RuboCop::AST::OrNode < RuboCop::AST::Node
  def alternate_operator; end
  def inverse_operator; end
  include RuboCop::AST::BinaryOperatorNode
  include RuboCop::AST::PredicateOperatorNode
end
class RuboCop::AST::PairNode < RuboCop::AST::Node
  def colon?; end
  def delimiter(with_spacing = nil); end
  def hash_rocket?; end
  def inverse_delimiter(with_spacing = nil); end
  def value_on_new_line?; end
  include RuboCop::AST::HashElementNode
end
class RuboCop::AST::RangeNode < RuboCop::AST::Node
  def begin; end
  def end; end
end
class RuboCop::AST::RegexpNode < RuboCop::AST::Node
  def content; end
  def regopt; end
  def to_regexp; end
end
class RuboCop::AST::ResbodyNode < RuboCop::AST::Node
  def body; end
  def exception_variable; end
end
class RuboCop::AST::RetryNode < RuboCop::AST::Node
  def arguments; end
  include RuboCop::AST::MethodDispatchNode
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::SelfClassNode < RuboCop::AST::Node
  def body; end
  def identifier; end
end
class RuboCop::AST::SendNode < RuboCop::AST::Node
  include RuboCop::AST::MethodDispatchNode
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::StrNode < RuboCop::AST::Node
  def heredoc?; end
  include RuboCop::AST::BasicLiteralNode
end
class RuboCop::AST::SuperNode < RuboCop::AST::Node
  def node_parts; end
  include RuboCop::AST::MethodDispatchNode
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::SymbolNode < RuboCop::AST::Node
  include RuboCop::AST::BasicLiteralNode
end
class RuboCop::AST::UntilNode < RuboCop::AST::Node
  def do?; end
  def inverse_keyword; end
  def keyword; end
  include RuboCop::AST::ConditionalNode
  include RuboCop::AST::ModifierNode
end
class RuboCop::AST::WhenNode < RuboCop::AST::Node
  def body; end
  def branch_index; end
  def conditions; end
  def each_condition; end
  def then?; end
end
class RuboCop::AST::WhileNode < RuboCop::AST::Node
  def do?; end
  def inverse_keyword; end
  def keyword; end
  include RuboCop::AST::ConditionalNode
  include RuboCop::AST::ModifierNode
end
class RuboCop::AST::YieldNode < RuboCop::AST::Node
  def node_parts; end
  include RuboCop::AST::MethodDispatchNode
  include RuboCop::AST::ParameterizedNode
end
class RuboCop::AST::Builder < Parser::Builders::Default
  def n(type, children, source_map); end
  def node_klass(type); end
  def string_value(token); end
end
module RuboCop::AST::Traversal
  def on_alias(node); end
  def on_and(node); end
  def on_and_asgn(node); end
  def on_arg(node); end
  def on_arg_expr(node); end
  def on_args(node); end
  def on_array(node); end
  def on_back_ref(node); end
  def on_begin(node); end
  def on_block(node); end
  def on_block_pass(node); end
  def on_blockarg(node); end
  def on_break(node); end
  def on_case(node); end
  def on_casgn(node); end
  def on_cbase(node); end
  def on_class(node); end
  def on_complex(node); end
  def on_const(node); end
  def on_csend(node); end
  def on_cvar(node); end
  def on_cvasgn(node); end
  def on_def(node); end
  def on_defined?(node); end
  def on_defs(node); end
  def on_dstr(node); end
  def on_dsym(node); end
  def on_eflipflop(node); end
  def on_ensure(node); end
  def on_erange(node); end
  def on_false(node); end
  def on_float(node); end
  def on_for(node); end
  def on_gvar(node); end
  def on_gvasgn(node); end
  def on_hash(node); end
  def on_if(node); end
  def on_iflipflop(node); end
  def on_int(node); end
  def on_irange(node); end
  def on_ivar(node); end
  def on_ivasgn(node); end
  def on_kwarg(node); end
  def on_kwbegin(node); end
  def on_kwoptarg(node); end
  def on_kwrestarg(node); end
  def on_kwsplat(node); end
  def on_lambda(node); end
  def on_lvar(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_match_current_line(node); end
  def on_match_with_lvasgn(node); end
  def on_mlhs(node); end
  def on_module(node); end
  def on_next(node); end
  def on_nil(node); end
  def on_not(node); end
  def on_nth_ref(node); end
  def on_op_asgn(node); end
  def on_optarg(node); end
  def on_or(node); end
  def on_or_asgn(node); end
  def on_pair(node); end
  def on_postexe(node); end
  def on_preexe(node); end
  def on_rational(node); end
  def on_redo(node); end
  def on_regexp(node); end
  def on_regopt(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_restarg(node); end
  def on_retry(node); end
  def on_return(node); end
  def on_sclass(node); end
  def on_self(node); end
  def on_send(node); end
  def on_shadowarg(node); end
  def on_splat(node); end
  def on_str(node); end
  def on_super(node); end
  def on_sym(node); end
  def on_true(node); end
  def on_undef(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_when(node); end
  def on_while(node); end
  def on_while_post(node); end
  def on_xstr(node); end
  def on_yield(node); end
  def on_zsuper(node); end
  def walk(node); end
end
class RuboCop::Error < StandardError
end
class RuboCop::ValidationError < RuboCop::Error
end
class RuboCop::Warning < StandardError
end
module RuboCop::Cop
end
module RuboCop::Cop::Util
  def begins_its_line?(range); end
  def comment_line?(line_source); end
  def compatible_external_encoding_for?(src); end
  def double_quotes_required?(string); end
  def escape_string(string); end
  def first_part_of_call_chain(node); end
  def interpret_string_escapes(string); end
  def line_range(node); end
  def needs_escaping?(string); end
  def on_node(syms, sexp, excludes = nil, &block); end
  def parentheses?(node); end
  def same_line?(node1, node2); end
  def self.begins_its_line?(range); end
  def self.comment_line?(line_source); end
  def self.double_quotes_required?(string); end
  def self.escape_string(string); end
  def self.first_part_of_call_chain(node); end
  def self.interpret_string_escapes(string); end
  def self.line_range(node); end
  def self.needs_escaping?(string); end
  def self.on_node(syms, sexp, excludes = nil, &block); end
  def self.parentheses?(node); end
  def self.same_line?(node1, node2); end
  def self.to_string_literal(string); end
  def self.to_supported_styles(enforced_style); end
  def self.tokens(node); end
  def self.trim_string_interporation_escape_character(str); end
  def to_string_literal(string); end
  def to_supported_styles(enforced_style); end
  def tokens(node); end
  def trim_string_interporation_escape_character(str); end
  include RuboCop::PathUtil
end
class RuboCop::Cop::Offense
  def <=>(other); end
  def ==(other); end
  def column; end
  def column_length; end
  def column_range; end
  def cop_name; end
  def corrected; end
  def corrected?; end
  def disabled?; end
  def eql?(other); end
  def first_line; end
  def hash; end
  def highlighted_area; end
  def initialize(severity, location, message, cop_name, status = nil); end
  def last_column; end
  def last_line; end
  def line; end
  def location; end
  def message; end
  def real_column; end
  def severity; end
  def source_line; end
  def status; end
  def to_s; end
  include Comparable
end
class RuboCop::Cop::MessageAnnotator
  def annotate(message, name); end
  def config; end
  def cop_config; end
  def debug?; end
  def details; end
  def display_cop_names?; end
  def display_style_guide?; end
  def extra_details?; end
  def initialize(config, cop_config, options); end
  def options; end
  def reference_urls; end
  def self.style_guide_urls; end
  def style_guide_url; end
  def urls; end
end
module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end
  def ignored_node?(node); end
  def ignored_nodes; end
  def part_of_ignored_node?(node); end
end
module RuboCop::Cop::AutocorrectLogic
  def autocorrect?; end
  def autocorrect_enabled?; end
  def autocorrect_requested?; end
  def support_autocorrect?; end
end
class RuboCop::Cop::Badge
  def ==(other); end
  def cop_name; end
  def department; end
  def eql?(other); end
  def hash; end
  def initialize(department, cop_name); end
  def match?(other); end
  def qualified?; end
  def self.for(class_name); end
  def self.parse(identifier); end
  def to_s; end
  def with_department(department); end
end
class RuboCop::Cop::Badge::InvalidBadge < RuboCop::Error
  def initialize(token); end
end
class RuboCop::Cop::AmbiguousCopName < RuboCop::Error
  def initialize(name, origin, badges); end
end
class RuboCop::Cop::Registry
  def ==(other); end
  def contains_cop_matching?(names); end
  def cops; end
  def departments; end
  def each(&block); end
  def enabled(config, only, only_safe = nil); end
  def enabled?(cop, config, only_safe); end
  def enlist(cop); end
  def find_by_cop_name(cop_name); end
  def initialize(cops = nil); end
  def length; end
  def names; end
  def qualified_cop_name(name, path); end
  def qualify_badge(badge); end
  def registered?(badge); end
  def resolve_badge(given_badge, real_badge, source_path); end
  def select(&block); end
  def sort!; end
  def to_h; end
  def with(cops); end
  def with_department(department); end
  def without_department(department); end
end
class RuboCop::Cop::Cop
  def add_offense(node, location: nil, message: nil, severity: nil); end
  def annotate(message); end
  def config; end
  def config_to_allow_offenses; end
  def config_to_allow_offenses=(hash); end
  def cop_config; end
  def cop_name; end
  def correct(node); end
  def corrections; end
  def custom_severity; end
  def default_severity; end
  def duplicate_location?(location); end
  def enabled_line?(line_number); end
  def excluded_file?(file); end
  def file_name_matches_any?(file, parameter, default_result); end
  def find_location(node, loc); end
  def initialize(config = nil, options = nil); end
  def join_force?(_force_class); end
  def message(_node = nil); end
  def name; end
  def offenses; end
  def parse(source, path = nil); end
  def processed_source; end
  def processed_source=(arg0); end
  def relevant_file?(file); end
  def self.all; end
  def self.autocorrect_incompatible_with; end
  def self.badge; end
  def self.cop_name; end
  def self.department; end
  def self.inherited(subclass); end
  def self.lint?; end
  def self.match?(given_names); end
  def self.non_rails; end
  def self.qualified_cop_name(name, origin); end
  def self.registry; end
  def target_rails_version; end
  def target_ruby_version; end
  extend RuboCop::AST::Sexp
  extend RuboCop::NodePattern::Macros
  include RuboCop::AST::Sexp
  include RuboCop::Cop::AutocorrectLogic
  include RuboCop::Cop::IgnoredNode
  include RuboCop::Cop::Util
end
class RuboCop::Cop::Commissioner
  def errors; end
  def initialize(cops, forces = nil, options = nil); end
  def investigate(processed_source); end
  def invoke_custom_post_walk_processing(cops, processed_source); end
  def invoke_custom_processing(cops_or_forces, processed_source); end
  def on_alias(node); end
  def on_and(node); end
  def on_and_asgn(node); end
  def on_arg(node); end
  def on_arg_expr(node); end
  def on_args(node); end
  def on_array(node); end
  def on_back_ref(node); end
  def on_begin(node); end
  def on_block(node); end
  def on_block_pass(node); end
  def on_blockarg(node); end
  def on_break(node); end
  def on_case(node); end
  def on_casgn(node); end
  def on_cbase(node); end
  def on_class(node); end
  def on_complex(node); end
  def on_const(node); end
  def on_csend(node); end
  def on_cvar(node); end
  def on_cvasgn(node); end
  def on_def(node); end
  def on_defined?(node); end
  def on_defs(node); end
  def on_dstr(node); end
  def on_dsym(node); end
  def on_eflipflop(node); end
  def on_ensure(node); end
  def on_erange(node); end
  def on_false(node); end
  def on_float(node); end
  def on_for(node); end
  def on_gvar(node); end
  def on_gvasgn(node); end
  def on_hash(node); end
  def on_if(node); end
  def on_iflipflop(node); end
  def on_int(node); end
  def on_irange(node); end
  def on_ivar(node); end
  def on_ivasgn(node); end
  def on_kwarg(node); end
  def on_kwbegin(node); end
  def on_kwoptarg(node); end
  def on_kwrestarg(node); end
  def on_kwsplat(node); end
  def on_lambda(node); end
  def on_lvar(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_match_current_line(node); end
  def on_match_with_lvasgn(node); end
  def on_mlhs(node); end
  def on_module(node); end
  def on_next(node); end
  def on_nil(node); end
  def on_not(node); end
  def on_nth_ref(node); end
  def on_op_asgn(node); end
  def on_optarg(node); end
  def on_or(node); end
  def on_or_asgn(node); end
  def on_pair(node); end
  def on_postexe(node); end
  def on_preexe(node); end
  def on_rational(node); end
  def on_redo(node); end
  def on_regexp(node); end
  def on_regopt(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_restarg(node); end
  def on_retry(node); end
  def on_return(node); end
  def on_sclass(node); end
  def on_self(node); end
  def on_send(node); end
  def on_shadowarg(node); end
  def on_splat(node); end
  def on_str(node); end
  def on_super(node); end
  def on_sym(node); end
  def on_true(node); end
  def on_undef(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_when(node); end
  def on_while(node); end
  def on_while_post(node); end
  def on_xstr(node); end
  def on_yield(node); end
  def on_zsuper(node); end
  def prepare(processed_source); end
  def remove_irrelevant_cops(filename); end
  def reset_callbacks; end
  def reset_errors; end
  def trigger_responding_cops(callback, node); end
  def with_cop_error_handling(cop, node = nil); end
  include RuboCop::AST::Traversal
end
class RuboCop::Cop::Commissioner::CopError < Struct
  def column; end
  def column=(_); end
  def error; end
  def error=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class RuboCop::Cop::Corrector
  def corrections; end
  def diagnostics; end
  def initialize(source_buffer, corrections = nil); end
  def insert_after(range, content); end
  def insert_before(range, content); end
  def remove(range); end
  def remove_leading(range, size); end
  def remove_preceding(range, size); end
  def remove_trailing(range, size); end
  def replace(range, content); end
  def rewrite; end
  def validate_range(range); end
end
class RuboCop::Cop::Force
  def cops; end
  def initialize(cops); end
  def investigate(_processed_source); end
  def name; end
  def run_hook(method_name, *args); end
  def self.all; end
  def self.force_name; end
  def self.inherited(subclass); end
end
class RuboCop::Cop::Severity
  def <=>(other); end
  def ==(other); end
  def code; end
  def hash; end
  def initialize(name_or_code); end
  def level; end
  def name; end
  def self.name_from_code(code); end
  def to_s; end
  include Comparable
end
class RuboCop::Cop::Generator
  def badge; end
  def bump_minor_version; end
  def generate(template); end
  def generated_source; end
  def generated_spec; end
  def github_user; end
  def initialize(name, github_user, output: nil); end
  def inject_config(config_file_path: nil); end
  def inject_require(root_file_path: nil); end
  def output; end
  def snake_case(camel_case_string); end
  def source_path; end
  def spec_path; end
  def todo; end
  def write_source; end
  def write_spec; end
  def write_unless_file_exists(path, contents); end
end
class RuboCop::Cop::Generator::ConfigurationInjector
  def badge; end
  def configuration_entries; end
  def configuration_file_path; end
  def cop_name_line?(yaml); end
  def find_target_line; end
  def initialize(configuration_file_path:, badge:, version_added:); end
  def inject; end
  def new_configuration_entry; end
  def output; end
  def version_added; end
end
class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: nil); end
  def inject; end
  def injectable_require_directive; end
  def output; end
  def require_entries; end
  def require_exists?; end
  def require_path; end
  def require_path_fragments(require_directove); end
  def root_file_path; end
  def source_path; end
  def target_line; end
  def updated_directives; end
end
class RuboCop::Cop::VariableForce < RuboCop::Cop::Force
  def after_declaring_variable(arg); end
  def after_entering_scope(arg); end
  def after_leaving_scope(arg); end
  def before_declaring_variable(arg); end
  def before_entering_scope(arg); end
  def before_leaving_scope(arg); end
  def descendant_reference(node); end
  def each_descendant_reference(loop_node); end
  def find_variables_in_loop(loop_node); end
  def inspect_variables_in_scope(scope_node); end
  def investigate(processed_source); end
  def mark_assignments_as_referenced_in_loop(node); end
  def node_handler_method_name(node); end
  def process_children(origin_node); end
  def process_loop(node); end
  def process_node(node); end
  def process_regexp_named_captures(node); end
  def process_rescue(node); end
  def process_scope(node); end
  def process_send(node); end
  def process_variable_assignment(node); end
  def process_variable_declaration(node); end
  def process_variable_multiple_assignment(node); end
  def process_variable_operator_assignment(node); end
  def process_variable_referencing(node); end
  def process_zero_arity_super(node); end
  def regexp_captured_names(node); end
  def scanned_node?(node); end
  def scanned_nodes; end
  def skip_children!; end
  def variable_table; end
end
class RuboCop::Cop::VariableForce::VariableReference < Struct
  def assignment?; end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class RuboCop::Cop::VariableForce::AssignmentReference < Struct
  def assignment?; end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: nil); end
end
class RuboCop::Cop::VariableForce::Branch::Base < Struct
  def ==(other); end
  def always_run?; end
  def branched?; end
  def child_node; end
  def child_node=(_); end
  def control_node; end
  def each_ancestor(include_self: nil, &block); end
  def eql?(other); end
  def exclusive_with?(other); end
  def hash; end
  def may_jump_to_other_branch?; end
  def may_run_incompletely?; end
  def parent; end
  def scan_ancestors; end
  def scope; end
  def scope=(_); end
  def self.[](*arg0); end
  def self.classes; end
  def self.define_predicate(name, child_index: nil); end
  def self.inherited(subclass); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def self.type; end
end
module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?; end
  def conditional_clause?; end
end
class RuboCop::Cop::VariableForce::Branch::If < RuboCop::Cop::VariableForce::Branch::Base
  def conditional_clause?; end
  def falsey_body?; end
  def truthy_body?; end
  include RuboCop::Cop::VariableForce::Branch::SimpleConditional
end
class RuboCop::Cop::VariableForce::Branch::While < RuboCop::Cop::VariableForce::Branch::Base
  def conditional_clause?; end
  def loop_body?; end
  include RuboCop::Cop::VariableForce::Branch::SimpleConditional
end
class RuboCop::Cop::VariableForce::Branch::Until < RuboCop::Cop::VariableForce::Branch::Base
  def conditional_clause?; end
  def loop_body?; end
  include RuboCop::Cop::VariableForce::Branch::SimpleConditional
end
class RuboCop::Cop::VariableForce::Branch::WhilePost < RuboCop::Cop::VariableForce::Branch::Base
  def conditional_clause?; end
  def loop_body?; end
  include RuboCop::Cop::VariableForce::Branch::SimpleConditional
end
class RuboCop::Cop::VariableForce::Branch::UntilPost < RuboCop::Cop::VariableForce::Branch::Base
  def conditional_clause?; end
  def loop_body?; end
  include RuboCop::Cop::VariableForce::Branch::SimpleConditional
end
class RuboCop::Cop::VariableForce::Branch::Case < RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def else_body?; end
  def target?; end
  def when_clause?; end
end
class RuboCop::Cop::VariableForce::Branch::For < RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def collection?; end
  def element?; end
  def loop_body?; end
end
module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?; end
end
class RuboCop::Cop::VariableForce::Branch::And < RuboCop::Cop::VariableForce::Branch::Base
  def left_body?; end
  def right_body?; end
  include RuboCop::Cop::VariableForce::Branch::LogicalOperator
end
class RuboCop::Cop::VariableForce::Branch::Or < RuboCop::Cop::VariableForce::Branch::Base
  def left_body?; end
  def right_body?; end
  include RuboCop::Cop::VariableForce::Branch::LogicalOperator
end
module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?; end
  def may_run_incompletely?; end
end
class RuboCop::Cop::VariableForce::Branch::Rescue < RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def else_body?; end
  def main_body?; end
  def rescue_clause?; end
  include RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end
class RuboCop::Cop::VariableForce::Branch::Ensure < RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def ensure_body?; end
  def main_body?; end
  include RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end
module RuboCop::Cop::VariableForce::Branchable
  def branch; end
  def run_exclusively_with?(other); end
end
class RuboCop::Cop::VariableForce::Variable
  def argument?; end
  def assign(node); end
  def assignments; end
  def block_argument?; end
  def capture_with_block!; end
  def captured_by_block; end
  def captured_by_block?; end
  def declaration_node; end
  def explicit_block_local_variable?; end
  def initialize(name, declaration_node, scope); end
  def keyword_argument?; end
  def method_argument?; end
  def name; end
  def reference!(node); end
  def referenced?; end
  def references; end
  def scope; end
  def should_be_unused?; end
  def used?; end
end
class RuboCop::Cop::VariableForce::Assignment
  def initialize(node, variable); end
  def meta_assignment_node; end
  def multiple_assignment?; end
  def multiple_assignment_node; end
  def name; end
  def node; end
  def operator; end
  def operator_assignment?; end
  def operator_assignment_node; end
  def reference!(node); end
  def referenced; end
  def referenced?; end
  def references; end
  def regexp_named_capture?; end
  def scope; end
  def used?; end
  def variable; end
  include RuboCop::Cop::VariableForce::Branchable
end
class RuboCop::Cop::VariableForce::Reference
  def explicit?; end
  def initialize(node, scope); end
  def node; end
  def scope; end
  include RuboCop::Cop::VariableForce::Branchable
end
class RuboCop::Cop::VariableForce::Scope
  def ==(other); end
  def ancestor_node?(target_node); end
  def belong_to_inner_scope?(target_node); end
  def belong_to_outer_scope?(target_node); end
  def body_node; end
  def each_node(&block); end
  def include?(target_node); end
  def initialize(node); end
  def naked_top_level; end
  def naked_top_level?; end
  def name; end
  def node; end
  def scan_node(node, &block); end
  def variables; end
end
class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables; end
  def assign_to_variable(name, node); end
  def current_scope; end
  def current_scope_level; end
  def declare_variable(name, node); end
  def find_variable(name); end
  def initialize(hook_receiver = nil); end
  def invoke_hook(hook_name, *args); end
  def mark_variable_as_captured_by_block_if_so(variable); end
  def pop_scope; end
  def push_scope(scope_node); end
  def reference_variable(name, node); end
  def scope_stack; end
  def variable_exist?(name); end
end
module RuboCop::Cop::Style
end
module RuboCop::Cop::Style::AnnotationComment
  def annotation?(comment); end
  def just_first_word_of_sentence?(first_word, colon, space, note); end
  def keyword?(word); end
  def keyword_appearance?(first_word, colon, space); end
  def split_comment(comment); end
end
module RuboCop::Cop::ArrayMinSize
  def array_style_detected(style, ary_size); end
  def below_array_length?(node); end
  def largest_brackets_size(style, ary_size); end
  def min_size_config; end
  def smallest_percent_size(style, ary_size); end
end
module RuboCop::Cop::ArraySyntax
  def bracketed_array_of?(element_type, node); end
end
module RuboCop::Cop::Alignment
  def check_alignment(items, base_column = nil); end
  def column_delta; end
  def configured_indentation_width; end
  def display_column(range); end
  def each_bad_alignment(items, base_column); end
  def end_of_line_comment(line); end
  def indentation(node); end
  def offset(node); end
  def within?(inner, outer); end
end
module RuboCop::Cop::CheckAssignment
  def extract_rhs(node); end
  def on_and_asgn(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
  def on_send(node); end
  def self.extract_rhs(node); end
end
module RuboCop::Cop::CheckLineBreakable
  def all_on_same_line?(nodes); end
  def already_on_multiple_lines?(node); end
  def breakable_collection?(node, elements); end
  def children_could_be_broken_up?(children); end
  def contained_by_breakable_collection_on_same_line?(node); end
  def contained_by_multiline_collection_that_could_be_broken_up?(node); end
  def extract_breakable_node(node, max); end
  def extract_breakable_node_from_elements(node, elements, max); end
  def extract_first_element_over_column_limit(node, elements, max); end
  def process_args(args); end
  def safe_to_ignore?(node); end
  def within_column_limit?(element, max, line); end
end
module RuboCop::Cop::ConfigurableMax
  def max=(value); end
  def max_parameter_name; end
end
module RuboCop::Cop::CodeLength
  def check_code_length(node); end
  def count_comments?; end
  def irrelevant_line(source_line); end
  def max_length; end
  include RuboCop::Cop::ConfigurableMax
end
module RuboCop::Cop::ClassishLength
  def code_length(node); end
  def line_numbers_of_inner_nodes(node, *types); end
  include RuboCop::Cop::CodeLength
end
module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style; end
  def alternative_styles; end
  def ambiguous_style_detected(*possibilities); end
  def conflicting_styles_detected; end
  def correct_style_detected; end
  def detected_style; end
  def detected_style=(style); end
  def no_acceptable_style!; end
  def no_acceptable_style?; end
  def opposite_style_detected; end
  def style; end
  def style_detected(detected); end
  def style_parameter_name; end
  def supported_styles; end
  def unexpected_style_detected(unexpected); end
  def unrecognized_style_detected; end
end
module RuboCop::Cop::ConfigurableFormatting
  def check_name(node, name, name_range); end
  def class_emitter_method?(node, name); end
  def report_opposing_styles(node, name); end
  def valid_name?(node, name, given_style = nil); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
module RuboCop::Cop::ConfigurableNaming
  include RuboCop::Cop::ConfigurableFormatting
end
module RuboCop::Cop::ConfigurableNumbering
  include RuboCop::Cop::ConfigurableFormatting
end
module RuboCop::Cop::DefNode
  def non_public?(node); end
  def non_public_modifier?(node = nil); end
  def preceding_non_public_modifier?(node); end
  def stripped_source_upto(index); end
  extend RuboCop::NodePattern::Macros
end
module RuboCop::Cop::DocumentationComment
  def constant_definition?(node = nil); end
  def documentation_comment?(node); end
  def interpreter_directive_comment?(comment); end
  def precede?(node1, node2); end
  def preceding_comment?(node1, node2); end
  def preceding_lines(node); end
  def rubocop_directive_comment?(comment); end
  extend RuboCop::NodePattern::Macros
  include RuboCop::Cop::Style::AnnotationComment
end
module RuboCop::Cop::Duplication
  def consecutive_duplicates(collection); end
  def duplicates(collection); end
  def duplicates?(collection); end
  def grouped_duplicates(collection); end
end
module RuboCop::Cop::RangeHelp
  def column_offset_between(base_range, range); end
  def directions(side); end
  def effective_column(range); end
  def final_pos(src, pos, increment, newlines, whitespace); end
  def move_pos(src, pos, step, condition, regexp); end
  def range_between(start_pos, end_pos); end
  def range_by_whole_lines(range, include_final_newline: nil); end
  def range_with_surrounding_comma(range, side = nil); end
  def range_with_surrounding_space(range:, side: nil, newlines: nil, whitespace: nil); end
  def source_range(source_buffer, line_number, column, length = nil); end
end
module RuboCop::Cop::Layout
end
module RuboCop::Cop::Layout::EmptyLinesAroundBody
  def check(node, body, adjusted_first_line: nil); end
  def check_beginning(style, first_line); end
  def check_both(style, first_line, last_line); end
  def check_deferred_empty_line(body); end
  def check_empty_lines_except_namespace(body, first_line, last_line); end
  def check_empty_lines_special(body, first_line, last_line); end
  def check_ending(style, last_line); end
  def check_line(style, line, msg); end
  def check_source(style, line_no, desc); end
  def constant_definition?(node = nil); end
  def deferred_message(node); end
  def empty_line_required?(node = nil); end
  def first_child_requires_empty_line?(body); end
  def first_empty_line_required_child(body); end
  def message(type, desc); end
  def namespace?(body, with_one_child: nil); end
  def previous_line_ignoring_comments(send_line); end
  def valid_body_style?(body); end
  extend RuboCop::NodePattern::Macros
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::EmptyParameter
  def check(node); end
  def empty_arguments?(node = nil); end
  extend RuboCop::NodePattern::Macros
end
module RuboCop::Cop::EndKeywordAlignment
  def add_offense_for_misalignment(node, align_with); end
  def check_end_kw_alignment(node, align_ranges); end
  def check_end_kw_in_node(node); end
  def line_break_before_keyword?(whole_expression, rhs); end
  def matching_ranges(end_loc, align_ranges); end
  def style_parameter_name; end
  def variable_alignment?(whole_expression, rhs, end_alignment_style); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end
  def on_send(node); end
  def self.included(base); end
end
module RuboCop::Cop::FirstElementLineBreak
  def check_children_line_break(node, children, start = nil); end
  def check_method_line_break(node, children); end
  def first_by_line(nodes); end
  def last_by_line(nodes); end
  def method_uses_parens?(node, limit); end
end
module RuboCop::Cop::FrozenStringLiteral
  def frozen_string_literal_comment_exists?; end
  def frozen_string_literals_enabled?; end
  def leading_comment_lines; end
  def self.frozen_string_literal_comment_exists?; end
end
module RuboCop::Cop::HashAlignment
end
class RuboCop::Cop::HashAlignment::KeyAlignment
  def checkable_layout?(_node); end
  def deltas(first_pair, current_pair); end
  def deltas_for_first_pair(first_pair, _node); end
  def separator_delta(pair); end
  def value_delta(pair); end
end
module RuboCop::Cop::HashAlignment::ValueAlignment
  def checkable_layout?(node); end
  def deltas(first_pair, current_pair); end
  def separator_delta(first_pair, current_pair, key_delta); end
end
class RuboCop::Cop::HashAlignment::TableAlignment
  def deltas_for_first_pair(first_pair, node); end
  def hash_rocket_delta(first_pair, current_pair); end
  def initialize; end
  def key_delta(first_pair, current_pair); end
  def max_key_width; end
  def max_key_width=(arg0); end
  def value_delta(first_pair, current_pair); end
  include RuboCop::Cop::HashAlignment::ValueAlignment
end
class RuboCop::Cop::HashAlignment::SeparatorAlignment
  def deltas_for_first_pair(*_nodes); end
  def hash_rocket_delta(first_pair, current_pair); end
  def key_delta(first_pair, current_pair); end
  def value_delta(first_pair, current_pair); end
  include RuboCop::Cop::HashAlignment::ValueAlignment
end
module RuboCop::Cop::IgnoredPattern
  def ignored_line?(line); end
  def ignored_patterns; end
  def matches_ignored_pattern?(line); end
end
module RuboCop::Cop::IgnoredMethods
  def ignored_method?(name); end
  def ignored_methods; end
end
module RuboCop::Cop::IgnoredMethodPatterns
  def ignored_method_pattern?(name); end
  def ignored_method_patterns; end
end
module RuboCop::Cop::IntegerNode
  def integer_part(node); end
end
module RuboCop::Cop::MatchRange
  def each_match_range(range, regex); end
  def match_range(range, match); end
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::MethodComplexity
  def check_complexity(node, method_name); end
  def complexity(body); end
  def define_method?(node = nil); end
  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end
  extend RuboCop::NodePattern::Macros
  include RuboCop::Cop::ConfigurableMax
end
module RuboCop::Cop::MethodPreference
  def default_cop_config; end
  def preferred_method(method); end
  def preferred_methods; end
end
module RuboCop::Cop::MinBodyLength
  def min_body_length; end
  def min_body_length?(node); end
end
module RuboCop::Cop::MultilineElementIndentation
  def base_column(left_brace, left_parenthesis); end
  def check_expected_style(styles); end
  def check_first(first, left_brace, left_parenthesis, offset); end
  def detected_styles(actual_column, offset, left_parenthesis, left_brace); end
  def detected_styles_for_column(column, left_parenthesis, left_brace); end
  def each_argument_node(node, type); end
  def incorrect_style_detected(styles, first, left_parenthesis); end
end
module RuboCop::Cop::MultilineElementLineBreaks
  def all_on_same_line?(nodes); end
  def check_line_breaks(_node, children); end
end
module RuboCop::Cop::MultilineExpressionIndentation
  def argument_in_method_call(node, kind); end
  def assignment_rhs(node); end
  def check(range, node, lhs, rhs); end
  def correct_indentation(node); end
  def disqualified_rhs?(candidate, ancestor); end
  def grouped_expression?(node); end
  def incorrect_style_detected(range, node, lhs, rhs); end
  def indentation(node); end
  def indented_keyword_expression(node); end
  def inside_arg_list_parentheses?(node, ancestor); end
  def keyword_message_tail(node); end
  def kw_node_with_special_indentation(node); end
  def left_hand_side(lhs); end
  def not_for_this_cop?(node); end
  def on_send(node); end
  def operation_description(node, rhs); end
  def part_of_assignment_rhs(node, candidate); end
  def part_of_block_body?(candidate, block_node); end
  def postfix_conditional?(node); end
  def regular_method_right_hand_side(send_node); end
  def right_hand_side(send_node); end
  def valid_method_rhs_candidate?(candidate, node); end
  def valid_rhs?(candidate, ancestor); end
  def valid_rhs_candidate?(candidate, node); end
  def within_node?(inner, outer); end
end
module RuboCop::Cop::MultilineLiteralBraceLayout
  def check(node); end
  def check_brace_layout(node); end
  def check_new_line(node); end
  def check_same_line(node); end
  def check_symmetrical(node); end
  def children(node); end
  def closing_brace_on_same_line?(node); end
  def empty_literal?(node); end
  def ignored_literal?(node); end
  def implicit_literal?(node); end
  def last_line_heredoc?(node, parent = nil); end
  def new_line_needed_before_closing_brace?(node); end
  def opening_brace_on_same_line?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
module RuboCop::Cop::NegativeConditional
  def check_negative_conditional(node); end
  def empty_condition?(node = nil); end
  def single_negative?(node = nil); end
  extend RuboCop::NodePattern::Macros
end
module RuboCop::Cop::Heredoc
  def delimiter_string(node); end
  def heredoc_type(node); end
  def on_dstr(node); end
  def on_heredoc(_node); end
  def on_str(node); end
  def on_xstr(node); end
end
module RuboCop::Cop::NilMethods
  def nil_methods; end
  def other_stdlib_methods; end
  def whitelist; end
end
module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end
module RuboCop::Cop::OrderedGemNode
  def case_insensitive_out_of_order?(string_a, string_b); end
  def consecutive_lines(previous, current); end
  def find_gem_name(gem_node); end
  def gem_name(declaration_node); end
  def get_source_range(node, comments_as_separators); end
  def register_offense(previous, current); end
  def treat_comments_as_separators; end
end
module RuboCop::Cop::Parentheses
  def parens_required?(node); end
end
module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end
module RuboCop::Cop::PercentArray
  def allowed_bracket_array?(node); end
  def check_bracketed_array(node); end
  def check_percent_array(node); end
  def comments_in_array?(node); end
  def invalid_percent_array_context?(node); end
  def message(_node); end
end
module RuboCop::Cop::PercentLiteral
  def begin_source(node); end
  def contents_range(node); end
  def percent_literal?(node); end
  def process(node, *types); end
  def type(node); end
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::PrecedingFollowingAlignment
  def aligned_assignment?(range, line); end
  def aligned_char?(range, line); end
  def aligned_comment_lines; end
  def aligned_identical?(range, line); end
  def aligned_operator?(range, line); end
  def aligned_token?(range, line); end
  def aligned_with_adjacent_line?(range, predicate); end
  def aligned_with_any_line?(line_ranges, range, indent = nil, &predicate); end
  def aligned_with_any_line_range?(line_ranges, range, &predicate); end
  def aligned_with_line?(line_nos, range, indent = nil); end
  def aligned_with_operator?(range); end
  def aligned_with_something?(range); end
  def aligned_words?(range, line); end
  def allow_for_alignment?; end
end
class RuboCop::Cop::PreferredDelimiters
  def config; end
  def delimiters; end
  def ensure_valid_preferred_delimiters; end
  def initialize(type, config, preferred_delimiters); end
  def preferred_delimiters; end
  def preferred_delimiters_config; end
  def type; end
end
module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
  def rescue_modifier?(node); end
end
module RuboCop::Cop::SafeAssignment
  def empty_condition?(node = nil); end
  def safe_assignment?(node = nil); end
  def safe_assignment_allowed?; end
  def setter_method?(node = nil); end
  extend RuboCop::NodePattern::Macros
end
module RuboCop::Cop::SafeMode
  def rails?; end
  def rails_safe_mode?; end
  def safe_mode?; end
end
module RuboCop::Cop::SpaceAfterPunctuation
  def allowed_type?(token); end
  def each_missing_space(tokens); end
  def investigate(processed_source); end
  def offset; end
  def space_forbidden_before_rcurly?; end
  def space_missing?(token1, token2); end
  def space_required_before?(token); end
end
module RuboCop::Cop::SpaceBeforePunctuation
  def each_missing_space(tokens); end
  def investigate(processed_source); end
  def space_missing?(token1, token2); end
  def space_required_after?(token); end
  def space_required_after_lcurly?; end
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::SurroundingSpace
  def empty_brackets?(left_bracket_token, right_bracket_token); end
  def empty_offense(node, range, message, command); end
  def empty_offenses(node, left, right, message); end
  def extra_space?(token, side); end
  def index_of_first_token(node); end
  def index_of_last_token(node); end
  def no_space_between?(left_bracket_token, right_bracket_token); end
  def no_space_offenses(node, left_token, right_token, message, start_ok: nil, end_ok: nil); end
  def offending_empty_no_space?(config, left_token, right_token); end
  def offending_empty_space?(config, left_token, right_token); end
  def reposition(src, pos, step); end
  def side_space_range(range:, side:); end
  def space_between?(left_bracket_token, right_bracket_token); end
  def space_offense(node, token, side, message, command); end
  def space_offenses(node, left_token, right_token, message, start_ok: nil, end_ok: nil); end
  def token_table; end
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::StatementModifier
  def indentation_multiplier; end
  def length_in_modifier_form(node, cond, body_length); end
  def max_line_length; end
  def modifier_fits_on_single_line?(node); end
  def non_eligible_body?(body); end
  def non_eligible_condition?(condition); end
  def non_eligible_node?(node); end
  def single_line_as_modifier?(node); end
end
module RuboCop::Cop::StringHelp
  def inside_interpolation?(node); end
  def on_regexp(node); end
  def on_str(node); end
end
module RuboCop::Cop::StringLiteralsHelp
  def wrong_quotes?(node); end
  include RuboCop::Cop::StringHelp
end
module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end
  def support_target_ruby_version?(version); end
end
module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end
  def support_target_rails_version?(version); end
end
module RuboCop::Cop::TooManyLines
  def code_length(node); end
  def extract_body(node); end
  def message(length, max_length); end
  include RuboCop::Cop::CodeLength
  include RuboCop::Cop::ConfigurableMax
end
module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end
  def first_part_of(body); end
  def trailing_body?(node); end
end
module RuboCop::Cop::TrailingComma
  def allowed_multiline_argument?(node); end
  def any_heredoc?(items); end
  def autocorrect_range(item); end
  def avoid_autocorrect?(_nodes); end
  def avoid_comma(kind, comma_begin_pos, extra_info); end
  def brackets?(node); end
  def check(node, items, kind, begin_pos, end_pos); end
  def check_comma(node, kind, comma_pos); end
  def check_literal(node, kind); end
  def elements(node); end
  def extra_avoid_comma_info; end
  def heredoc?(node); end
  def heredoc_send?(node); end
  def inside_comment?(range, comma_offset); end
  def method_name_and_arguments_on_same_line?(node); end
  def multiline?(node); end
  def no_elements_on_same_line?(node); end
  def on_same_line?(range1, range2); end
  def put_comma(node, items, kind); end
  def should_have_comma?(style, node); end
  def style_parameter_name; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::UncommunicativeName
  def allow_nums; end
  def allowed_names; end
  def arg_range(arg, length); end
  def case_offense(node, range); end
  def check(node, args); end
  def ends_with_num?(name); end
  def forbidden_names; end
  def forbidden_offense(node, range, name); end
  def issue_offenses(node, range, name); end
  def length_offense(node, range); end
  def long_enough?(name); end
  def min_length; end
  def name_type(node); end
  def num_offense(node, range); end
  def uppercase?(name); end
end
module RuboCop::Cop::Lint
end
module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
  def check_argument(variable); end
  def join_force?(force_class); end
  extend RuboCop::NodePattern::Macros
end
class RuboCop::Cop::AlignmentCorrector
  def self.align_end(processed_source, node, align_to); end
  def self.alignment_column(align_to); end
  def self.autocorrect_line(corrector, line_begin_pos, expr, column_delta, heredoc_ranges); end
  def self.block_comment_within?(expr); end
  def self.calculate_range(expr, line_begin_pos, column_delta); end
  def self.correct(processed_source, node, column_delta); end
  def self.each_line(expr); end
  def self.heredoc_ranges(node); end
  def self.processed_source; end
  def self.remove(range, corrector); end
  def self.whitespace_range(node); end
  extend RuboCop::Cop::Alignment
  extend RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
  def self.negated_condition(node); end
end
class RuboCop::Cop::EachToForCorrector
  def argument_node; end
  def block_node; end
  def call(corrector); end
  def collection_node; end
  def correction; end
  def initialize(block_node); end
  def offending_range; end
  def replacement_range(end_pos); end
  extend RuboCop::NodePattern::Macros
end
class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end
  def self.insert_before(node); end
end
class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end
  def collection_end; end
  def collection_node; end
  def collection_source; end
  def correction; end
  def end_position; end
  def for_node; end
  def initialize(for_node); end
  def keyword_begin; end
  def offending_range; end
  def replacement_range(end_pos); end
  def requires_parentheses?; end
  def variable_node; end
  extend RuboCop::NodePattern::Macros
end
class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def arg_to_unparenthesized_call?; end
  def arguments; end
  def arguments_begin_pos; end
  def arguments_end_pos; end
  def block_begin; end
  def block_end; end
  def block_node; end
  def call(corrector); end
  def initialize(block_node); end
  def insert_arguments(corrector); end
  def insert_separating_space(corrector); end
  def lambda_arg_string; end
  def method; end
  def needs_separating_space?; end
  def remove_arguments(corrector); end
  def remove_leading_whitespace(corrector); end
  def remove_trailing_whitespace(corrector); end
  def remove_unparenthesized_whitespace(corrector); end
  def replace_delimiters(corrector); end
  def replace_selector(corrector); end
  def selector_end; end
  def separating_space?; end
end
class RuboCop::Cop::LineBreakCorrector
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: nil); end
  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end
  def self.move_comment(eol_comment:, node:, corrector:); end
  def self.processed_source; end
  def self.remove_semicolon(node, corrector); end
  def self.semicolon(node); end
  extend RuboCop::Cop::Alignment
  extend RuboCop::Cop::TrailingBody
  extend RuboCop::Cop::Util
end
class RuboCop::Cop::MultilineLiteralBraceCorrector
  def call(corrector); end
  def correct_next_line_brace(corrector); end
  def correct_same_line_brace(corrector); end
  def initialize(node, processed_source); end
  def last_element_range_with_trailing_comma(node); end
  def last_element_trailing_comma_range(node); end
  def node; end
  def processed_source; end
  include RuboCop::Cop::MultilineLiteralBraceLayout
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::OrderedGemCorrector
  def self.comments_as_separators; end
  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end
  def self.declaration_with_comment(node); end
  def self.processed_source; end
  def self.swap_range(corrector, range1, range2); end
  extend RuboCop::Cop::OrderedGemNode
end
class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
  def self.next_char_is_question_mark?(node); end
  def self.ternary_condition?(node); end
end
class RuboCop::Cop::PercentLiteralCorrector
  def autocorrect_multiline_words(node, escape, delimiters); end
  def autocorrect_words(node, escape, delimiters); end
  def config; end
  def correct(node, char); end
  def delimiters_for(type); end
  def end_content(source); end
  def escape_words?(node); end
  def first_line?(node, previous_line_num); end
  def fix_escaped_content(word_node, escape, delimiters); end
  def initialize(config, preferred_delimiters); end
  def line_breaks(node, source, previous_line_num, base_line_num, node_indx); end
  def new_contents(node, escape, delimiters); end
  def preferred_delimiters; end
  def process_lines(node, previous_line_num, base_line_num, source_in_lines); end
  def process_multiline_words(node, escape, delimiters); end
  def substitute_escaped_delimiters(content, delimiters); end
  def wrap_contents(node, contents, char, delimiters); end
  include RuboCop::Cop::Util
end
class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end
  def self.remove_space(space_before); end
  def self.swap_comma(range); end
end
class RuboCop::Cop::SpaceCorrector
  def self.add_space(processed_source, corrector, left_token, right_token); end
  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end
  def self.processed_source; end
  def self.remove_space(processed_source, corrector, left_token, right_token); end
  extend RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::StringLiteralCorrector
  def self.correct(node, style); end
  extend RuboCop::Cop::Util
end
class RuboCop::Cop::UnusedArgCorrector
  def self.correct(processed_source, node); end
  def self.correct_for_blockarg_type(node); end
  def self.processed_source; end
  extend RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::Bundler
end
class RuboCop::Cop::Bundler::DuplicatedGem < RuboCop::Cop::Cop
  def duplicated_gem_nodes; end
  def gem_declarations(node0); end
  def investigate(processed_source); end
  def register_offense(node, gem_name, line_of_first_occurrence); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Bundler::GemComment < RuboCop::Cop::Cop
  def commented?(node); end
  def gem_declaration?(node = nil); end
  def on_send(node); end
  def precede?(node1, node2); end
  def preceding_comment?(node1, node2); end
  def preceding_lines(node); end
  def whitelisted_gem?(node); end
  include RuboCop::Cop::DefNode
end
class RuboCop::Cop::Bundler::InsecureProtocolSource < RuboCop::Cop::Cop
  def autocorrect(node); end
  def insecure_protocol_source?(node = nil); end
  def on_send(node); end
  def range(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Bundler::OrderedGems < RuboCop::Cop::Cop
  def autocorrect(node); end
  def gem_declarations(node0); end
  def investigate(processed_source); end
  def previous_declaration(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::OrderedGemNode
end
module RuboCop::Cop::Gemspec
end
class RuboCop::Cop::Gemspec::DuplicatedAssignment < RuboCop::Cop::Cop
  def assignment_method?(method_name); end
  def assignment_method_declarations(node0); end
  def duplicated_assignment_method_nodes; end
  def gem_specification(node0); end
  def investigate(processed_source); end
  def match_block_variable_name?(receiver_name); end
  def register_offense(node, assignment, line_of_first_occurrence); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Gemspec::OrderedDependencies < RuboCop::Cop::Cop
  def autocorrect(node); end
  def dependency_declarations(node0); end
  def get_dependency_name(node); end
  def investigate(processed_source); end
  def previous_declaration(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::OrderedGemNode
end
class RuboCop::Cop::Gemspec::RequiredRubyVersion < RuboCop::Cop::Cop
  def extract_ruby_version(required_ruby_version); end
  def investigate(processed_source); end
  def message(required_ruby_version, target_ruby_version); end
  def required_ruby_version(node0); end
end
class RuboCop::Cop::Layout::AccessModifierIndentation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_body(body, node); end
  def check_modifier(send_node, end_range); end
  def expected_indent_offset; end
  def message(node); end
  def on_block(node); end
  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end
  def unexpected_indent_offset; end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::AlignArguments < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_column(node, args); end
  def fixed_indentation?; end
  def message(_node); end
  def on_csend(node); end
  def on_send(node); end
  def target_method_lineno(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Layout::AlignArray < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_array(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Layout::AlignHash < RuboCop::Cop::Cop
  def add_offences; end
  def adjust(corrector, delta, range); end
  def alignment_for(pair); end
  def alignment_for_colons; end
  def alignment_for_hash_rockets; end
  def autocorrect(node); end
  def check_delta(delta, node:, alignment:); end
  def check_pairs(node); end
  def column_deltas; end
  def column_deltas=(arg0); end
  def correct_key_value(delta, key, value, separator); end
  def correct_no_value(key_delta, key); end
  def correct_node(node, delta); end
  def double_splat?(node); end
  def good_alignment?(column_deltas); end
  def ignore_hash_argument?(node); end
  def new_alignment(key); end
  def offences_by; end
  def offences_by=(arg0); end
  def on_hash(node); end
  def on_send(node); end
  def on_super(node); end
  def on_yield(node); end
  include RuboCop::Cop::HashAlignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::AlignParameters < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_column(node, args); end
  def fixed_indentation?; end
  def message(_node); end
  def on_def(node); end
  def on_defs(node); end
  def target_method_lineno(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Layout::BlockAlignment < RuboCop::Cop::Cop
  def add_space_before(loc, delta); end
  def alt_start_msg(start_loc, source_line_column); end
  def autocorrect(node); end
  def block_end_align_target(node); end
  def block_end_align_target?(node = nil, param1); end
  def check_block_alignment(start_node, block_node); end
  def compute_do_source_line_column(node, end_loc); end
  def compute_start_col(ancestor_node, node); end
  def disqualified_parent?(parent, node); end
  def end_align_target?(node, parent); end
  def format_message(start_loc, end_loc, do_source_line_column, error_source_line_column); end
  def format_source_line_column(source_line_column); end
  def loc_to_source_line_column(loc); end
  def on_block(node); end
  def register_offense(block_node, start_loc, end_loc, do_source_line_column); end
  def remove_space_before(end_pos, delta); end
  def start_for_block_node(block_node); end
  def style_parameter_name; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::BlockEndNewline < RuboCop::Cop::Cop
  def autocorrect(node); end
  def delimiter_range(node); end
  def message(node); end
  def on_block(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Layout::CaseIndentation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_column(case_node, base); end
  def check_when(when_node); end
  def incorrect_style(when_node); end
  def indent_one_step?; end
  def indentation_width; end
  def message(base); end
  def on_case(case_node); end
  def replacement(node); end
  def whitespace_range(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::ClassStructure < RuboCop::Cop::Cop
  def autocorrect(node); end
  def begin_pos_with_comment(node); end
  def buffer; end
  def categories; end
  def class_elements(class_node); end
  def classify(node); end
  def end_position_for(node); end
  def expected_order; end
  def find_category(node); end
  def find_visibility_end(node); end
  def find_visibility_start(node); end
  def humanize_node(node); end
  def ignore?(classification); end
  def left_siblings_of(node); end
  def node_visibility(node); end
  def on_class(class_node); end
  def right_siblings_of(node); end
  def siblings_of(node); end
  def source_range_with_comment(node); end
  def start_line_position(node); end
  def visibility_block?(node = nil); end
  def walk_over_nested_class_definition(class_node); end
end
class RuboCop::Cop::Layout::ClosingHeredocIndentation < RuboCop::Cop::Cop
  def argument_indentation_correct?(node); end
  def autocorrect(node); end
  def closing_indentation(node); end
  def find_node_used_heredoc_argument(node); end
  def heredoc_closing(node); end
  def heredoc_opening(node); end
  def indent_level(source_line); end
  def indented_end(node); end
  def message(node); end
  def on_heredoc(node); end
  def opening_indentation(node); end
  include RuboCop::Cop::Heredoc
end
class RuboCop::Cop::Layout::ClosingParenthesisIndentation < RuboCop::Cop::Cop
  def all_elements_aligned?(elements); end
  def autocorrect(node); end
  def check(node, elements); end
  def check_for_elements(node, elements); end
  def check_for_no_elements(node); end
  def correct_column_candidates(node, left_paren); end
  def expected_column(left_paren, elements); end
  def first_argument_line(elements); end
  def indentation_width; end
  def line_break_after_left_paren?(left_paren, elements); end
  def message(correct_column, left_paren, right_paren); end
  def on_begin(node); end
  def on_csend(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Layout::CommentIndentation < RuboCop::Cop::Cop
  def autocorrect(comment); end
  def autocorrect_one(comment); end
  def autocorrect_preceding_comments(comment); end
  def check(comment); end
  def correct_indentation(next_line); end
  def investigate(processed_source); end
  def less_indented?(line); end
  def line_after_comment(comment); end
  def message(column, correct_comment_indentation); end
  def own_line_comment?(comment); end
  def should_correct?(comment, column, line_no); end
  def two_alternatives?(line); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Layout::ConditionPosition < RuboCop::Cop::Cop
  def check(node); end
  def message(node); end
  def on_if(node); end
  def on_until(node); end
  def on_while(node); end
end
class RuboCop::Cop::Layout::DefEndAlignment < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  include RuboCop::Cop::EndKeywordAlignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::DotPosition < RuboCop::Cop::Cop
  def ampersand_dot?(node); end
  def autocorrect(node); end
  def correct_dot_position_style?(dot_line, selector_line); end
  def line_between?(first_line, second_line); end
  def message(node); end
  def on_csend(node); end
  def on_send(node); end
  def proper_dot_position?(node); end
  def selector_range(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Layout::ElseAlignment < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_for_method_definition(node); end
  def base_range_of_if(node, base); end
  def base_range_of_rescue(node); end
  def check_alignment(base_range, else_range); end
  def check_assignment(node, rhs); end
  def check_nested(node, base); end
  def on_case(node); end
  def on_if(node, base = nil); end
  def on_rescue(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::CheckAssignment
  include RuboCop::Cop::EndKeywordAlignment
end
class RuboCop::Cop::Layout::EmptyComment < RuboCop::Cop::Cop
  def allow_border_comment?; end
  def allow_margin_comment?; end
  def autocorrect(node); end
  def comment_text(comment); end
  def concat_consecutive_comments(comments); end
  def current_token(node); end
  def empty_comment_only?(comment_text); end
  def investigate(processed_source); end
  def previous_token(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EmptyLineAfterGuardClause < RuboCop::Cop::Cop
  def autocorrect(node); end
  def contains_guard_clause?(node); end
  def correct_style?(node); end
  def heredoc_line(node, heredoc_node); end
  def last_argument(node); end
  def last_argument_is_heredoc?(node); end
  def next_line_empty?(line); end
  def next_line_rescue_or_ensure?(node); end
  def next_sibling_empty_or_guard_clause?(node); end
  def next_sibling_parent_empty_or_else?(node); end
  def offense_location(node); end
  def on_if(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EmptyLineAfterMagicComment < RuboCop::Cop::Cop
  def autocorrect(token); end
  def investigate(source); end
  def last_magic_comment(source); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EmptyLineBetweenDefs < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_insert_lines(newline_pos, count); end
  def autocorrect_remove_lines(newline_pos, count); end
  def blank_lines_between?(first_def_node, second_def_node); end
  def blank_lines_count_between(first_def_node, second_def_node); end
  def check_defs(nodes); end
  def def_end(node); end
  def def_node?(node); end
  def def_start(node); end
  def lines_between_defs(first_def_node, second_def_node); end
  def maximum_empty_lines; end
  def minimum_empty_lines; end
  def multiple_blank_lines_groups?(first_def_node, second_def_node); end
  def on_begin(node); end
  def prev_node(node); end
  def self.autocorrect_incompatible_with; end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier < RuboCop::Cop::Cop
  def allowed_only_before_style?(node); end
  def autocorrect(node); end
  def block_start?(line); end
  def body_end?(line); end
  def class_def?(line); end
  def correct_next_line_if_denied_style(corrector, node, line); end
  def empty_lines_around?(node); end
  def initialize(config = nil, options = nil); end
  def message(node); end
  def message_for_around_style(node); end
  def message_for_only_before_style(node); end
  def next_empty_line_range(node); end
  def next_line_empty?(last_send_line); end
  def on_block(node); end
  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end
  def on_send(node); end
  def previous_line_empty?(send_line); end
  def previous_line_ignoring_comments(processed_source, send_line); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EmptyLinesAroundArguments < RuboCop::Cop::Cop
  def autocorrect(node); end
  def empty_lines(node); end
  def extra_lines(node); end
  def inner_lines(node); end
  def line_numbers(node); end
  def on_csend(node); end
  def on_send(node); end
  def outer_lines(node); end
  def processed_lines(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_kwbegin(node); end
  def style; end
  include RuboCop::Cop::Layout::EmptyLinesAroundBody
end
class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_block(node); end
  include RuboCop::Cop::Layout::EmptyLinesAroundBody
end
class RuboCop::Cop::Layout::EmptyLinesAroundClassBody < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_class(node); end
  def on_sclass(node); end
  include RuboCop::Cop::Layout::EmptyLinesAroundBody
end
class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_body(node); end
  def keyword_locations(node); end
  def keyword_locations_in_ensure(node); end
  def keyword_locations_in_rescue(node); end
  def message(location, keyword); end
  def on_def(node); end
  def on_defs(node); end
  def on_kwbegin(node); end
  def style; end
  include RuboCop::Cop::Layout::EmptyLinesAroundBody
end
class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
  def style; end
  include RuboCop::Cop::Layout::EmptyLinesAroundBody
end
class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_module(node); end
  include RuboCop::Cop::Layout::EmptyLinesAroundBody
end
class RuboCop::Cop::Layout::EmptyLines < RuboCop::Cop::Cop
  def autocorrect(range); end
  def each_extra_empty_line(lines); end
  def exceeds_line_offset?(line_diff); end
  def investigate(processed_source); end
  def previous_and_current_lines_empty?(line); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EndAlignment < RuboCop::Cop::Cop
  def alignment_node(node); end
  def alignment_node_for_variable_style(node); end
  def asgn_variable_align_with(outer_node, inner_node); end
  def autocorrect(node); end
  def check_asgn_alignment(outer_node, inner_node); end
  def check_assignment(node, rhs); end
  def check_other_alignment(node); end
  def on_case(node); end
  def on_class(node); end
  def on_if(node); end
  def on_module(node); end
  def on_until(node); end
  def on_while(node); end
  def start_line_range(node); end
  include RuboCop::Cop::CheckAssignment
  include RuboCop::Cop::EndKeywordAlignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::EndOfLine < RuboCop::Cop::Cop
  def investigate(processed_source); end
  def offense_message(line); end
  def unimportant_missing_cr?(index, last_line, line); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::ExtraSpacing < RuboCop::Cop::Cop
  def align_column(asgn_token); end
  def align_equal_sign(corrector, token, align_to); end
  def align_equal_signs(range, corrector); end
  def aligned_comments?(comment_token); end
  def aligned_tok?(token); end
  def aligned_with_next_comment?(index); end
  def aligned_with_previous_comment?(index); end
  def allow_for_trailing_comments?; end
  def assignment_tokens; end
  def autocorrect(range); end
  def check_assignment(token); end
  def check_other(token1, token2, ast); end
  def check_tokens(ast, token1, token2); end
  def comment_column(index); end
  def contiguous_assignment_lines(range); end
  def extra_space_range(token1, token2); end
  def force_equal_sign_alignment?; end
  def ignored_range?(ast, start_pos); end
  def ignored_ranges(ast); end
  def investigate(processed_source); end
  def remove_optarg_equals(asgn_tokens, processed_source); end
  def should_aligned_with_preceding_line?(token); end
  def unary_plus_non_offense?(range); end
  include RuboCop::Cop::PrecedingFollowingAlignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::FirstArrayElementLineBreak < RuboCop::Cop::Cop
  def assignment_on_same_line?(node); end
  def autocorrect(node); end
  def on_array(node); end
  include RuboCop::Cop::FirstElementLineBreak
end
class RuboCop::Cop::Layout::FirstHashElementLineBreak < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_hash(node); end
  include RuboCop::Cop::FirstElementLineBreak
end
class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_csend(node); end
  def on_send(node); end
  def on_super(node); end
  include RuboCop::Cop::FirstElementLineBreak
end
class RuboCop::Cop::Layout::FirstMethodParameterLineBreak < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::FirstElementLineBreak
end
class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis < RuboCop::Cop::Cop
  def add_correct_closing_paren(node, corrector); end
  def add_correct_external_trailing_comma(node, corrector); end
  def autocorrect(node); end
  def external_trailing_comma?(node); end
  def external_trailing_comma_offset_from_loc_end(node); end
  def extract_heredoc(node); end
  def extract_heredoc_argument(node); end
  def fix_closing_parenthesis(node, corrector); end
  def fix_external_trailing_comma(node, corrector); end
  def heredoc_node?(node); end
  def incorrect_parenthesis_removal_begin(node); end
  def incorrect_parenthesis_removal_end(node); end
  def internal_trailing_comma?(node); end
  def internal_trailing_comma_offset_from_last_arg(node); end
  def on_send(node); end
  def outermost_send_on_same_line(heredoc); end
  def remove_incorrect_closing_paren(node, corrector); end
  def remove_incorrect_external_trailing_comma(node, corrector); end
  def remove_internal_trailing_comma(node, corrector); end
  def safe_to_remove_line_containing_closing_paren?(node); end
  def self.autocorrect_incompatible_with; end
  def send_missing_closing_parens?(parent, child, heredoc); end
  def single_line_send_with_heredoc_receiver?(node); end
  def space?(pos); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::IndentAssignment < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_assignment(node, rhs); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::CheckAssignment
end
class RuboCop::Cop::Layout::IndentationConsistency < RuboCop::Cop::Cop
  def autocorrect(node); end
  def bare_access_modifier?(node); end
  def base_column_for_normal_style(node); end
  def check(node); end
  def check_normal_style(node); end
  def check_rails_style(node); end
  def on_begin(node); end
  def on_kwbegin(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Layout::IndentationWidth < RuboCop::Cop::Cop
  def access_modifier?(node = nil); end
  def autocorrect(node); end
  def check_assignment(node, rhs); end
  def check_if(node, body, else_clause, base_loc); end
  def check_indentation(base_loc, body_node, style = nil); end
  def check_members(base, members); end
  def check_members_for_rails_style(members); end
  def configured_indentation_width; end
  def each_member(members); end
  def indentation_consistency_style; end
  def indentation_to_check?(base_loc, body_node); end
  def leftmost_modifier_of(node); end
  def message(configured_indentation_width, indentation, name); end
  def offending_range(body_node, indentation); end
  def offense(body_node, indentation, style); end
  def on_block(node); end
  def on_case(case_node); end
  def on_class(node); end
  def on_csend(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_ensure(node); end
  def on_for(node); end
  def on_if(node, base = nil); end
  def on_kwbegin(node); end
  def on_module(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_sclass(node); end
  def on_send(node); end
  def on_until(node, base = nil); end
  def on_while(node, base = nil); end
  def other_offense_in_same_range?(node); end
  def select_check_member(member); end
  def skip_check?(base_loc, body_node); end
  def starts_with_access_modifier?(body_node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::CheckAssignment
  include RuboCop::Cop::EndKeywordAlignment
  include RuboCop::Cop::IgnoredPattern
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::IndentFirstArgument < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_indentation(node); end
  def base_range(send_node, arg_node); end
  def column_of(range); end
  def eligible_method_call?(node = nil); end
  def message(arg_node); end
  def on_csend(node); end
  def on_send(node); end
  def previous_code_line(line_number); end
  def special_inner_call_indentation?(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::IndentFirstArrayElement < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_description(left_parenthesis); end
  def brace_alignment_style; end
  def check(array_node, left_parenthesis); end
  def check_right_bracket(right_bracket, left_bracket, left_parenthesis); end
  def message(base_description); end
  def on_array(node); end
  def on_csend(node); end
  def on_send(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::MultilineElementIndentation
end
class RuboCop::Cop::Layout::IndentFirstHashElement < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_description(left_parenthesis); end
  def brace_alignment_style; end
  def check(hash_node, left_parenthesis); end
  def check_based_on_longest_key(hash_node, left_brace, left_parenthesis); end
  def check_right_brace(right_brace, left_brace, left_parenthesis); end
  def message(base_description); end
  def on_csend(node); end
  def on_hash(node); end
  def on_send(node); end
  def separator_style?(first_pair); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::MultilineElementIndentation
end
class RuboCop::Cop::Layout::IndentFirstParameter < RuboCop::Cop::Cop
  def autocorrect(node); end
  def base_description(_); end
  def brace_alignment_style; end
  def check(def_node); end
  def message(base_description); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::MultilineElementIndentation
end
class RuboCop::Cop::Layout::IndentHeredoc < RuboCop::Cop::Cop
  def adjust_minus(corrector, node); end
  def adjust_squiggly(corrector, node); end
  def autocorrect(node); end
  def base_indent_level(node); end
  def check_style!; end
  def correct_by_library(node); end
  def correct_by_squiggly(node); end
  def heredoc_body(node); end
  def heredoc_end(node); end
  def heredoc_indent_type(node); end
  def indent_level(str); end
  def indentation_width; end
  def indented_body(node); end
  def indented_end(node); end
  def library_message(indentation_width, method); end
  def line_too_long?(node); end
  def longest_line(lines); end
  def max_line_length; end
  def message(node); end
  def on_heredoc(node); end
  def ruby23_message(indentation_width, current_indent_type); end
  def ruby23_type_message(indentation_width, current_indent_type); end
  def ruby23_width_message(indentation_width); end
  def unlimited_heredoc_length?; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::Heredoc
  include RuboCop::Cop::SafeMode
end
class RuboCop::Cop::Layout::InitialIndentation < RuboCop::Cop::Cop
  def autocorrect(range); end
  def first_token; end
  def investigate(_processed_source); end
  def space_before(token); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::LeadingBlankLines < RuboCop::Cop::Cop
  def autocorrect(node); end
  def investigate(processed_source); end
end
class RuboCop::Cop::Layout::LeadingCommentSpace < RuboCop::Cop::Cop
  def allowed_on_first_line?(comment); end
  def autocorrect(comment); end
  def investigate(processed_source); end
  def rackup_config_file?; end
  def rackup_options?(comment); end
  def shebang?(comment); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::MultilineArrayBraceLayout < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_array(node); end
  include RuboCop::Cop::MultilineLiteralBraceLayout
end
class RuboCop::Cop::Layout::MultilineArrayLineBreaks < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_array(node); end
  include RuboCop::Cop::MultilineElementLineBreaks
end
class RuboCop::Cop::Layout::MultilineAssignmentLayout < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_assignment(node, rhs); end
  def check_by_enforced_style(node, rhs); end
  def check_new_line_offense(node, rhs); end
  def check_same_line_offense(node, rhs); end
  def supported_types; end
  include RuboCop::Cop::CheckAssignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::MultilineBlockLayout < RuboCop::Cop::Cop
  def add_offense_for_expression(node, expr, msg); end
  def args_on_beginning_line?(node); end
  def autocorrect(node); end
  def autocorrect_arguments(corrector, node); end
  def autocorrect_body(corrector, node, block_body); end
  def block_arg_string(args); end
  def on_block(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::MultilineHashBraceLayout < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_hash(node); end
  def self.autocorrect_incompatible_with; end
  include RuboCop::Cop::MultilineLiteralBraceLayout
end
class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_hash(node); end
  def starts_with_curly_brace?(node); end
  include RuboCop::Cop::MultilineElementLineBreaks
end
class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  include RuboCop::Cop::MultilineElementLineBreaks
end
class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout < RuboCop::Cop::Cop
  def autocorrect(node); end
  def children(node); end
  def ignored_literal?(node); end
  def on_send(node); end
  def single_line_ignoring_receiver?(node); end
  include RuboCop::Cop::MultilineLiteralBraceLayout
end
class RuboCop::Cop::Layout::MultilineMethodCallIndentation < RuboCop::Cop::Cop
  def align_with_base_message(rhs); end
  def alignment_base(node, rhs, given_style); end
  def autocorrect(node); end
  def base_source; end
  def extra_indentation(given_style); end
  def message(node, lhs, rhs); end
  def no_base_message(lhs, rhs, node); end
  def offending_range(node, lhs, rhs, given_style); end
  def operation_rhs(node); end
  def operator_rhs?(node, receiver); end
  def receiver_alignment_base(node); end
  def relative_to_receiver_message(rhs); end
  def relevant_node?(send_node); end
  def semantic_alignment_base(node, rhs); end
  def semantic_alignment_node(node); end
  def should_align_with_base?; end
  def should_indent_relative_to_receiver?; end
  def syntactic_alignment_base(lhs, rhs); end
  def validate_config; end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::MultilineExpressionIndentation
end
class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::MultilineLiteralBraceLayout
end
class RuboCop::Cop::Layout::MultilineOperationIndentation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_and_or(node); end
  def message(node, lhs, rhs); end
  def offending_range(node, lhs, rhs, given_style); end
  def on_and(node); end
  def on_or(node); end
  def relevant_node?(node); end
  def should_align?(node, rhs, given_style); end
  def validate_config; end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::MultilineExpressionIndentation
end
class RuboCop::Cop::Layout::RescueEnsureAlignment < RuboCop::Cop::Cop
  def access_modifier_node(node); end
  def alignment_node(node); end
  def alignment_source(node, starting_loc); end
  def ancestor_node(node); end
  def assignment_node(node); end
  def autocorrect(node); end
  def check(node); end
  def format_message(alignment_node, alignment_loc, kw_loc); end
  def investigate(processed_source); end
  def modifier?(node); end
  def on_ensure(node); end
  def on_resbody(node); end
  def whitespace_range(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceAfterColon < RuboCop::Cop::Cop
  def autocorrect(range); end
  def followed_by_space?(colon); end
  def on_kwoptarg(node); end
  def on_pair(node); end
end
class RuboCop::Cop::Layout::SpaceAfterComma < RuboCop::Cop::Cop
  def autocorrect(comma); end
  def kind(token); end
  def space_style_before_rcurly; end
  include RuboCop::Cop::SpaceAfterPunctuation
end
class RuboCop::Cop::Layout::SpaceAfterMethodName < RuboCop::Cop::Cop
  def autocorrect(pos_before_left_paren); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceAfterNot < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  def whitespace_after_operator?(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceAfterSemicolon < RuboCop::Cop::Cop
  def autocorrect(semicolon); end
  def kind(token); end
  def space_style_before_rcurly; end
  include RuboCop::Cop::SpaceAfterPunctuation
end
class RuboCop::Cop::Layout::SpaceAroundBlockParameters < RuboCop::Cop::Cop
  def autocorrect(target); end
  def check_after_closing_pipe(arguments); end
  def check_arg(arg); end
  def check_closing_pipe_space(args, closing_pipe); end
  def check_each_arg(args); end
  def check_inside_pipes(arguments); end
  def check_no_space(space_begin_pos, space_end_pos, msg); end
  def check_no_space_style_inside_pipes(args, opening_pipe, closing_pipe); end
  def check_opening_pipe_space(args, opening_pipe); end
  def check_space(space_begin_pos, space_end_pos, range, msg, node = nil); end
  def check_space_style_inside_pipes(args, opening_pipe, closing_pipe); end
  def last_end_pos_inside_pipes(pos); end
  def on_block(node); end
  def pipes(arguments); end
  def pipes?(arguments); end
  def style_parameter_name; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault < RuboCop::Cop::Cop
  def autocorrect(range); end
  def check_optarg(arg, equals, value); end
  def incorrect_style_detected(arg, value, space_on_both_sides, no_surrounding_space); end
  def message(_node); end
  def no_surrounding_space?(arg, equals); end
  def on_optarg(node); end
  def space_on_both_sides?(arg, equals); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Layout::SpaceAroundKeyword < RuboCop::Cop::Cop
  def accept_left_parenthesis?(range); end
  def accept_left_square_bracket?(range); end
  def accepted_opening_delimiter?(range, char); end
  def autocorrect(range); end
  def check(node, locations, begin_keyword = nil); end
  def check_begin(node, range, begin_keyword); end
  def check_end(node, range, begin_keyword); end
  def check_keyword(node, range); end
  def do?(node); end
  def offense(range, msg); end
  def on_and(node); end
  def on_block(node); end
  def on_break(node); end
  def on_case(node); end
  def on_defined?(node); end
  def on_ensure(node); end
  def on_for(node); end
  def on_if(node); end
  def on_kwbegin(node); end
  def on_next(node); end
  def on_or(node); end
  def on_postexe(node); end
  def on_preexe(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_return(node); end
  def on_send(node); end
  def on_super(node); end
  def on_until(node); end
  def on_when(node); end
  def on_while(node); end
  def on_yield(node); end
  def on_zsuper(node); end
  def preceded_by_operator?(node, _range); end
  def safe_navigation_call?(range, pos); end
  def space_after_missing?(range); end
  def space_before_missing?(range); end
end
class RuboCop::Cop::Layout::SpaceAroundOperators < RuboCop::Cop::Cop
  def align_hash_cop_config; end
  def autocorrect(range); end
  def check_operator(operator, right_operand); end
  def excess_leading_space?(operator, with_space); end
  def excess_trailing_space?(right_operand, with_space); end
  def hash_table_style?; end
  def offense(operator, with_space, right_operand); end
  def offense_message(operator, with_space, right_operand); end
  def on_and(node); end
  def on_and_asgn(node); end
  def on_binary(node); end
  def on_casgn(node); end
  def on_class(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_if(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_op_asgn(node); end
  def on_or(node); end
  def on_or_asgn(node); end
  def on_pair(node); end
  def on_resbody(node); end
  def on_send(node); end
  def on_special_asgn(node); end
  def operator_with_regular_syntax?(send_node); end
  def regular_operator?(send_node); end
  def self.autocorrect_incompatible_with; end
  include RuboCop::Cop::PrecedingFollowingAlignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceBeforeBlockBraces < RuboCop::Cop::Cop
  def autocorrect(range); end
  def check_empty(left_brace, space_plus_brace, used_style); end
  def check_non_empty(left_brace, space_plus_brace, used_style); end
  def empty_braces?(loc); end
  def on_block(node); end
  def self.autocorrect_incompatible_with; end
  def space_detected(left_brace, space_plus_brace); end
  def space_missing(left_brace); end
  def style_for_empty_braces; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceBeforeComma < RuboCop::Cop::Cop
  def autocorrect(space); end
  def kind(token); end
  include RuboCop::Cop::SpaceBeforePunctuation
end
class RuboCop::Cop::Layout::SpaceBeforeComment < RuboCop::Cop::Cop
  def autocorrect(range); end
  def investigate(processed_source); end
end
class RuboCop::Cop::Layout::SpaceBeforeFirstArg < RuboCop::Cop::Cop
  def autocorrect(range); end
  def expect_params_after_method_name?(node); end
  def on_csend(node); end
  def on_send(node); end
  def regular_method_call_with_arguments?(node); end
  include RuboCop::Cop::PrecedingFollowingAlignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceBeforeSemicolon < RuboCop::Cop::Cop
  def autocorrect(space); end
  def kind(token); end
  include RuboCop::Cop::SpaceBeforePunctuation
end
class RuboCop::Cop::Layout::SpaceInLambdaLiteral < RuboCop::Cop::Cop
  def arrow_lambda_with_args?(node); end
  def autocorrect(lambda_node); end
  def on_send(node); end
  def range_of_offense(node); end
  def space_after_arrow?(lambda_node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral < RuboCop::Cop::Cop
  def autocorrect(node); end
  def each_unnecessary_space_match(node, &blk); end
  def on_array(node); end
  def on_percent_literal(node); end
  include RuboCop::Cop::MatchRange
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets < RuboCop::Cop::Cop
  def array_brackets(node); end
  def autocorrect(node); end
  def compact_corrections(corrector, node, left, right); end
  def compact_offense(node, token, side: nil); end
  def compact_offenses(node, left, right, start_ok, end_ok); end
  def empty_config; end
  def end_has_own_line?(token); end
  def index_for(node, token); end
  def issue_offenses(node, left, right, start_ok, end_ok); end
  def left_array_bracket(node); end
  def line_and_column_for(token); end
  def multi_dimensional_array?(node, token, side: nil); end
  def next_to_bracket?(token, side: nil); end
  def next_to_comment?(node, token); end
  def next_to_newline?(node, token); end
  def on_array(node); end
  def qualifies_for_compact?(node, token, side: nil); end
  def right_array_bracket(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Layout::SpaceInsideBlockBraces < RuboCop::Cop::Cop
  def adjacent_braces(left_brace, right_brace); end
  def autocorrect(range); end
  def braces_with_contents_inside(node, inner); end
  def check_inside(node, left_brace, right_brace); end
  def check_left_brace(inner, left_brace, args_delimiter); end
  def check_right_brace(inner, right_brace, single_line); end
  def no_space(begin_pos, end_pos, msg); end
  def no_space_inside_left_brace(left_brace, args_delimiter); end
  def offense(begin_pos, end_pos, msg, &block); end
  def on_block(node); end
  def pipe?(args_delimiter); end
  def space(begin_pos, end_pos, msg); end
  def space_inside_left_brace(left_brace, args_delimiter); end
  def space_inside_right_brace(right_brace); end
  def style_for_empty_braces; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces < RuboCop::Cop::Cop
  def ambiguous_or_unexpected_style_detected(style, is_match); end
  def autocorrect(range); end
  def check(token1, token2); end
  def expect_space?(token1, token2); end
  def hash_literal_with_braces(node); end
  def incorrect_style_detected(token1, token2, expect_space, is_empty_braces); end
  def message(brace, is_empty_braces, expect_space); end
  def offense?(token1, expect_space); end
  def on_hash(node); end
  def range_of_space_to_the_left(range); end
  def range_of_space_to_the_right(range); end
  def space_range(token_range); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Layout::SpaceInsideParens < RuboCop::Cop::Cop
  def autocorrect(range); end
  def can_be_ignored?(token1, token2); end
  def each_extraneous_space(tokens); end
  def each_missing_space(tokens); end
  def investigate(processed_source); end
  def parens?(token1, token2); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters < RuboCop::Cop::Cop
  def add_offenses_for_unnecessary_spaces(node); end
  def autocorrect(node); end
  def on_array(node); end
  def on_percent_literal(node); end
  def on_xstr(node); end
  def regex_matches(node, &blk); end
  include RuboCop::Cop::MatchRange
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Layout::SpaceInsideRangeLiteral < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def on_erange(node); end
  def on_irange(node); end
end
class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets < RuboCop::Cop::Cop
  def autocorrect(node); end
  def bracket_method?(node); end
  def closing_bracket(tokens, opening_bracket); end
  def empty_config; end
  def left_ref_bracket(node, tokens); end
  def on_send(node); end
  def previous_token(current_token); end
  def reference_brackets(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Layout::SpaceInsideStringInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def each_style_violation(node); end
  def message(_node); end
  def on_dstr(node); end
  def space_on_any_side?(node); end
  def space_on_each_side?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::Tab < RuboCop::Cop::Cop
  def autocorrect(range); end
  def in_string_literal?(ranges, line, col); end
  def investigate(processed_source); end
  def string_literal_ranges(ast); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::TrailingBlankLines < RuboCop::Cop::Cop
  def autocorrect(range); end
  def ends_in_end?(processed_source); end
  def investigate(processed_source); end
  def message(wanted_blank_lines, blank_lines); end
  def offense_detected(buffer, wanted_blank_lines, blank_lines, whitespace_at_end); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Layout::TrailingWhitespace < RuboCop::Cop::Cop
  def autocorrect(range); end
  def extract_heredoc_ranges(ast); end
  def inside_heredoc?(heredoc_ranges, line_number); end
  def investigate(processed_source); end
  def skip_heredoc?; end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::AmbiguousBlockAssociation < RuboCop::Cop::Cop
  def allowed_method?(node); end
  def ambiguous_block_association?(send_node); end
  def message(send_node); end
  def on_csend(node); end
  def on_send(node); end
end
class RuboCop::Cop::Lint::AmbiguousOperator < RuboCop::Cop::Cop
  def alternative_message(diagnostic); end
  def relevant_diagnostic?(diagnostic); end
  include RuboCop::Cop::ParserDiagnostic
end
class RuboCop::Cop::Lint::AmbiguousRegexpLiteral < RuboCop::Cop::Cop
  def alternative_message(_diagnostic); end
  def relevant_diagnostic?(diagnostic); end
  include RuboCop::Cop::ParserDiagnostic
end
class RuboCop::Cop::Lint::AssignmentInCondition < RuboCop::Cop::Cop
  def allowed_construct?(asgn_node); end
  def conditional_assignment?(asgn_node); end
  def message(_node); end
  def on_if(node); end
  def on_until(node); end
  def on_while(node); end
  def skip_children?(asgn_node); end
  def traverse_node(node, types, &block); end
  include RuboCop::Cop::SafeAssignment
end
class RuboCop::Cop::Lint::BigDecimalNew < RuboCop::Cop::Cop
  def autocorrect(node); end
  def big_decimal_new(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Lint::BooleanSymbol < RuboCop::Cop::Cop
  def boolean_symbol?(node = nil); end
  def on_sym(node); end
end
class RuboCop::Cop::Lint::CircularArgumentReference < RuboCop::Cop::Cop
  def check_for_circular_argument_references(arg_name, arg_value); end
  def on_kwoptarg(node); end
  def on_optarg(node); end
end
class RuboCop::Cop::Lint::Debugger < RuboCop::Cop::Cop
  def binding_irb?(node); end
  def binding_irb_call?(node = nil); end
  def debugger_call?(node = nil); end
  def kernel?(node = nil); end
  def message(node); end
  def on_send(node); end
  def pry_rescue?(node = nil); end
end
class RuboCop::Cop::Lint::DeprecatedClassMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def deprecated_method(data); end
  def method_call(class_constant, method); end
  def on_send(node); end
  def replacement_method(data); end
end
class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  def class_constant; end
  def class_nodes; end
  def deprecated_method; end
  def initialize(deprecated:, replacement:, class_constant: nil); end
  def replacement_method; end
  include RuboCop::AST::Sexp
end
class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor < RuboCop::Cop::Cop
  def check(node); end
  def check_body(body); end
  def check_body_lines(lines); end
  def check_disjunctive_assignment(node); end
  def on_def(node); end
end
class RuboCop::Cop::Lint::DuplicateCaseCondition < RuboCop::Cop::Cop
  def on_case(case_node); end
  def repeated_condition?(previous, condition); end
end
class RuboCop::Cop::Lint::DuplicateMethods < RuboCop::Cop::Cop
  def alias_method?(node = nil); end
  def attr?(node = nil); end
  def check_const_receiver(node, name, const_name); end
  def check_self_receiver(node, name); end
  def found_attr(node, args, readable: nil, writable: nil); end
  def found_instance_method(node, name); end
  def found_method(node, method_name); end
  def initialize(config = nil, options = nil); end
  def lookup_constant(node, const_name); end
  def message_for_dup(node, method_name); end
  def method_alias?(node = nil); end
  def on_alias(node); end
  def on_attr(node, attr_name, args); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def possible_dsl?(node); end
  def qualified_name(enclosing, namespace, mod_name); end
  def source_location(node); end
  def sym_name(node = nil); end
end
class RuboCop::Cop::Lint::DuplicatedKey < RuboCop::Cop::Cop
  def on_hash(node); end
  include RuboCop::Cop::Duplication
end
class RuboCop::Cop::Lint::EachWithObjectArgument < RuboCop::Cop::Cop
  def each_with_object?(node = nil); end
  def on_csend(node); end
  def on_send(node); end
end
class RuboCop::Cop::Lint::ElseLayout < RuboCop::Cop::Cop
  def check(node); end
  def check_else(node); end
  def on_if(node); end
end
class RuboCop::Cop::Lint::EmptyEnsure < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_ensure(node); end
end
class RuboCop::Cop::Lint::EmptyExpression < RuboCop::Cop::Cop
  def empty_expression?(begin_node); end
  def on_begin(node); end
end
class RuboCop::Cop::Lint::EmptyInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_dstr(node); end
end
class RuboCop::Cop::Lint::EmptyWhen < RuboCop::Cop::Cop
  def on_case(node); end
end
class RuboCop::Cop::Lint::EndInMethod < RuboCop::Cop::Cop
  def on_postexe(node); end
end
class RuboCop::Cop::Lint::EnsureReturn < RuboCop::Cop::Cop
  def on_ensure(node); end
end
class RuboCop::Cop::Lint::ErbNewArguments < RuboCop::Cop::Cop
  def correct_arguments?(arguments); end
  def erb_new_with_non_keyword_arguments(node = nil); end
  def on_send(node); end
  extend RuboCop::Cop::TargetRubyVersion
end
class RuboCop::Cop::Lint::FlipFlop < RuboCop::Cop::Cop
  def on_eflipflop(node); end
  def on_iflipflop(node); end
end
class RuboCop::Cop::Lint::FloatOutOfRange < RuboCop::Cop::Cop
  def on_float(node); end
end
class RuboCop::Cop::Lint::FormatParameterMismatch < RuboCop::Cop::Cop
  def arguments_count(format); end
  def called_on_string?(node = nil); end
  def count_format_matches(node); end
  def count_matches(node); end
  def count_percent_matches(node); end
  def countable_format?(node); end
  def countable_percent?(node); end
  def expected_fields_count(node); end
  def format?(node); end
  def format_method?(name, node); end
  def heredoc?(node); end
  def matched_arguments_count?(expected, passed); end
  def max_digit_dollar_num(node); end
  def message(node); end
  def method_with_format_args?(node); end
  def named_mode?(node); end
  def offending_node?(node); end
  def on_send(node); end
  def percent?(node); end
  def splat_args?(node); end
  def sprintf?(node); end
end
class RuboCop::Cop::Lint::HandleExceptions < RuboCop::Cop::Cop
  def comment_lines?(node); end
  def on_resbody(node); end
end
class RuboCop::Cop::Lint::HeredocMethodCallPosition < RuboCop::Cop::Cop
  def all_on_same_line?(nodes); end
  def autocorrect(node); end
  def call_after_heredoc_range(heredoc); end
  def call_end_pos(node); end
  def call_line_range(node); end
  def call_range_to_safely_reposition(node, heredoc); end
  def calls_on_multiple_lines?(node, _heredoc); end
  def correctly_positioned?(node, heredoc); end
  def heredoc_begin_line_range(heredoc); end
  def heredoc_end_pos(heredoc); end
  def heredoc_node?(node); end
  def heredoc_node_descendent_receiver(node); end
  def on_csend(node); end
  def on_send(node); end
  def send_node?(node); end
  def trailing_comma?(call_source, call_line_source); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::ImplicitStringConcatenation < RuboCop::Cop::Cop
  def display_str(node); end
  def each_bad_cons(node); end
  def ending_delimiter(str); end
  def on_dstr(node); end
  def str_content(node); end
  def string_literal?(node); end
  def string_literals?(node1, node2); end
end
class RuboCop::Cop::Lint::InheritException < RuboCop::Cop::Cop
  def autocorrect(node); end
  def class_new_call?(node = nil); end
  def illegal_class_name?(class_node); end
  def message(node); end
  def on_class(node); end
  def on_send(node); end
  def preferred_base_class; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Lint::IneffectiveAccessModifier < RuboCop::Cop::Cop
  def access_modifier?(node); end
  def check_node(node); end
  def correct_visibility?(node, modifier, ignored_methods); end
  def format_message(modifier); end
  def ineffective_modifier(node, ignored_methods, modifier = nil, &block); end
  def on_class(node); end
  def on_module(node); end
  def private_class_method_names(node); end
  def private_class_methods(node0); end
end
class RuboCop::Cop::Lint::InterpolationCheck < RuboCop::Cop::Cop
  def heredoc?(node); end
  def on_str(node); end
end
class RuboCop::Cop::Lint::LiteralAsCondition < RuboCop::Cop::Cop
  def basic_literal?(node); end
  def check_case(case_node); end
  def check_for_literal(node); end
  def check_node(node); end
  def condition(node); end
  def handle_node(node); end
  def message(node); end
  def on_case(case_node); end
  def on_if(node); end
  def on_send(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end
  def primitive_array?(node); end
end
class RuboCop::Cop::Lint::LiteralInInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrected_value(node); end
  def autocorrected_value_for_array(node); end
  def autocorrected_value_for_string(node); end
  def autocorrected_value_for_symbol(node); end
  def on_dstr(node); end
  def prints_as_self?(node); end
  def special_keyword?(node); end
  include RuboCop::Cop::PercentLiteral
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::Loop < RuboCop::Cop::Cop
  def on_until_post(node); end
  def on_while_post(node); end
  def register_offense(node); end
end
class RuboCop::Cop::Lint::MissingCopEnableDirective < RuboCop::Cop::Cop
  def investigate(processed_source); end
  def message(max_range:, cop:); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::MultipleCompare < RuboCop::Cop::Cop
  def autocorrect(node); end
  def multiple_compare?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Lint::NestedMethodDefinition < RuboCop::Cop::Cop
  def class_or_module_or_struct_new_call?(node = nil); end
  def eval_call?(node = nil); end
  def exec_call?(node = nil); end
  def find_nested_defs(node, &block); end
  def on_def(node); end
  def on_defs(node); end
  def scoping_method_call?(child); end
end
class RuboCop::Cop::Lint::NestedPercentLiteral < RuboCop::Cop::Cop
  def contains_percent_literals?(node); end
  def on_array(node); end
  def on_percent_literal(node); end
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Lint::NextWithoutAccumulator < RuboCop::Cop::Cop
  def on_block(node); end
  def on_body_of_reduce(node = nil); end
  def parent_block_node(node); end
end
class RuboCop::Cop::Lint::NonLocalExitFromIterator < RuboCop::Cop::Cop
  def chained_send?(node = nil); end
  def define_method?(node = nil); end
  def on_return(return_node); end
  def return_value?(return_node); end
  def scoped_node?(node); end
end
class RuboCop::Cop::Lint::NumberConversion < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_method(node, receiver); end
  def date_time_object?(node); end
  def datetime?(node = nil); end
  def on_send(node); end
  def to_method(node = nil); end
end
class RuboCop::Cop::Lint::OrderedMagicComments < RuboCop::Cop::Cop
  def autocorrect(_node); end
  def investigate(processed_source); end
  def magic_comment_lines; end
  def magic_comments; end
  include RuboCop::Cop::FrozenStringLiteral
end
class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression < RuboCop::Cop::Cop
  def on_csend(node); end
  def on_send(node); end
  def space_range(expr, space_length); end
  def spaces_before_left_parenthesis(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::PercentStringArray < RuboCop::Cop::Cop
  def autocorrect(node); end
  def contains_quotes_or_commas?(node); end
  def on_array(node); end
  def on_percent_literal(node); end
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Lint::PercentSymbolArray < RuboCop::Cop::Cop
  def autocorrect(node); end
  def contains_colons_or_commas?(node); end
  def non_alphanumeric_literal?(literal); end
  def on_array(node); end
  def on_percent_literal(node); end
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Lint::RandOne < RuboCop::Cop::Cop
  def message(node); end
  def on_send(node); end
  def rand_one?(node = nil); end
end
class RuboCop::Cop::Lint::RedundantWithIndex < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_block(node); end
  def redundant_with_index?(node = nil); end
  def with_index_range(send); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::RedundantWithObject < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_block(node); end
  def redundant_with_object?(node = nil); end
  def with_object_range(send); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::RegexpAsCondition < RuboCop::Cop::Cop
  def on_match_current_line(node); end
end
class RuboCop::Cop::Lint::RequireParentheses < RuboCop::Cop::Cop
  def check_predicate(predicate, node); end
  def check_ternary(ternary, node); end
  def on_csend(node); end
  def on_send(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::RescueException < RuboCop::Cop::Cop
  def on_resbody(node); end
  def targets_exception?(rescue_arg_node); end
end
class RuboCop::Cop::Lint::RescueType < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correction(*exceptions); end
  def invalid_exceptions(exceptions); end
  def on_resbody(node); end
  def valid_exceptions(exceptions); end
  include RuboCop::Cop::RescueNode
end
class RuboCop::Cop::Lint::ReturnInVoidContext < RuboCop::Cop::Cop
  def method_name(context_node); end
  def non_void_context(return_node); end
  def on_return(return_node); end
  def setter_method?(method_name); end
  def void_context_method?(method_name); end
end
class RuboCop::Cop::Lint::SafeNavigationConsistency < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def on_csend(node); end
  def top_conditional_ancestor(node); end
  def unsafe_method_calls(method_calls, safe_nav_receiver); end
  include RuboCop::Cop::IgnoredNode
  include RuboCop::Cop::NilMethods
end
class RuboCop::Cop::Lint::SafeNavigationChain < RuboCop::Cop::Cop
  def bad_method?(node = nil); end
  def method_chain(node); end
  def on_send(node); end
  include RuboCop::Cop::NilMethods
end
class RuboCop::Cop::Lint::SafeNavigationWithEmpty < RuboCop::Cop::Cop
  def on_if(node); end
  def safe_navigation_empty_in_conditional?(node = nil); end
end
class RuboCop::Cop::Lint::ScriptPermission < RuboCop::Cop::Cop
  def autocorrect(node); end
  def executable?(processed_source); end
  def format_message_from(processed_source); end
  def investigate(processed_source); end
end
class RuboCop::Cop::Lint::ShadowedArgument < RuboCop::Cop::Cop
  def after_leaving_scope(scope, _variable_table); end
  def argument_references(argument); end
  def assignment_without_argument_usage(argument); end
  def check_argument(argument); end
  def ignore_implicit_references?; end
  def join_force?(force_class); end
  def node_within_block_or_conditional?(node, stop_search_node); end
  def reference_pos(node); end
  def shadowing_assignment(argument); end
  def uses_var?(node0, param1); end
end
class RuboCop::Cop::Lint::ShadowedException < RuboCop::Cop::Cop
  def compare_exceptions(exception, other_exception); end
  def contains_multiple_levels_of_exceptions?(group); end
  def evaluate_exceptions(rescue_group); end
  def find_shadowing_rescue(rescues); end
  def offense_range(rescues); end
  def on_rescue(node); end
  def rescued_exceptions(rescue_group); end
  def rescued_groups_for(rescues); end
  def silence_warnings; end
  def sorted?(rescued_groups); end
  def system_call_err?(error); end
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::RescueNode
end
class RuboCop::Cop::Lint::ShadowingOuterLocalVariable < RuboCop::Cop::Cop
  def before_declaring_variable(variable, variable_table); end
  def join_force?(force_class); end
end
class RuboCop::Cop::Lint::StringConversionInInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_dstr(node); end
  def to_s_without_args?(node = nil); end
end
class RuboCop::Cop::Lint::Syntax < RuboCop::Cop::Cop
  def add_offense_from_diagnostic(diagnostic, ruby_version); end
  def add_offense_from_error(error); end
  def beautify_message(message); end
  def self.offenses_from_processed_source(processed_source, config, options); end
end
class RuboCop::Cop::Lint::Syntax::PseudoSourceRange < Struct
  def begin_pos; end
  def begin_pos=(_); end
  def column; end
  def column=(_); end
  def end_pos; end
  def end_pos=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source_line; end
  def source_line=(_); end
end
class RuboCop::Cop::Lint::ToJSON < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
end
class RuboCop::Cop::Lint::UnderscorePrefixedVariableName < RuboCop::Cop::Cop
  def after_leaving_scope(scope, _variable_table); end
  def allowed_keyword_block_argument?(variable); end
  def check_variable(variable); end
  def join_force?(force_class); end
end
class RuboCop::Cop::Lint::UnifiedInteger < RuboCop::Cop::Cop
  def autocorrect(node); end
  def fixnum_or_bignum_const(node = nil); end
  def on_const(node); end
end
class RuboCop::Cop::Lint::UnneededCopDisableDirective < RuboCop::Cop::Cop
  def add_offense_for_entire_comment(comment, cops); end
  def add_offense_for_some_cops(comment, cops); end
  def add_offenses(unneeded_cops); end
  def all_cop_names; end
  def all_disabled?(comment); end
  def autocorrect(args); end
  def check(offenses, cop_disabled_line_ranges, comments); end
  def collect_variable_like_names(scope); end
  def comment_range_with_surrounding_space(range); end
  def cop_range(comment, cop); end
  def describe(cop); end
  def directive_count(comment); end
  def directive_range_in_list(range, ranges); end
  def each_already_disabled(line_ranges, disabled_ranges, comments); end
  def each_line_range(line_ranges, disabled_ranges, offenses, comments, cop); end
  def each_unneeded_disable(cop_disabled_line_ranges, offenses, comments, &block); end
  def ends_its_line?(range); end
  def find_unneeded(comment, offenses, cop, line_range, next_line_range); end
  def ignore_offense?(disabled_ranges, line_range); end
  def matching_range(haystack, needle); end
  def trailing_range?(ranges, range); end
  include RuboCop::Cop::RangeHelp
  include RuboCop::NameSimilarity
end
class RuboCop::Cop::Lint::UnneededCopEnableDirective < RuboCop::Cop::Cop
  def all_or_name(name); end
  def autocorrect(comment_and_name); end
  def comment_start(comment); end
  def cop_name_indention(comment, name); end
  def investigate(processed_source); end
  def range_of_offense(comment, name); end
  def range_to_remove(begin_pos, end_pos, comma_pos, comment); end
  def range_with_comma(comment, name); end
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Lint::UnneededRequireStatement < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  def unnecessary_require_statement?(node = nil); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Lint::UnneededSplatExpansion < RuboCop::Cop::Cop
  def array_new?(node = nil); end
  def array_new_inside_array_literal?(array_new_node); end
  def array_splat?(node); end
  def autocorrect(node); end
  def literal_expansion(node = nil); end
  def method_argument?(node); end
  def on_splat(node); end
  def part_of_an_array?(node); end
  def remove_brackets(array); end
  def replacement_range_and_content(node); end
  def unneeded_brackets?(node); end
  def unneeded_splat_expansion(node); end
end
class RuboCop::Cop::Lint::UnreachableCode < RuboCop::Cop::Cop
  def check_case(node); end
  def check_if(node); end
  def flow_command?(node = nil); end
  def flow_expression?(node); end
  def on_begin(node); end
  def on_kwbegin(node); end
end
class RuboCop::Cop::Lint::UnusedBlockArgument < RuboCop::Cop::Cop
  def allow_unused_keyword_arguments?; end
  def allowed_block?(variable); end
  def allowed_keyword_argument?(variable); end
  def augment_message(message, variable); end
  def autocorrect(node); end
  def check_argument(variable); end
  def define_method_call?(variable); end
  def empty_block?(variable); end
  def ignore_empty_blocks?; end
  def message(variable); end
  def message_for_lambda(variable, all_arguments); end
  def message_for_normal_block(variable, all_arguments); end
  def message_for_underscore_prefix(variable); end
  def variable_type(variable); end
  include RuboCop::Cop::Lint::UnusedArgument
end
class RuboCop::Cop::Lint::UnusedMethodArgument < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_argument(variable); end
  def message(variable); end
  include RuboCop::Cop::Lint::UnusedArgument
end
class RuboCop::Cop::Lint::UriEscapeUnescape < RuboCop::Cop::Cop
  def on_send(node); end
  def uri_escape_unescape?(node = nil); end
end
class RuboCop::Cop::Lint::UriRegexp < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  def register_offense(node, top_level: nil, arg: nil); end
  def uri_regexp_with_argument?(node = nil); end
  def uri_regexp_without_argument?(node = nil); end
end
class RuboCop::Cop::Lint::UselessAccessModifier < RuboCop::Cop::Cop
  def access_modifier?(node); end
  def any_context_creating_methods?(child); end
  def any_method_definition?(child); end
  def check_child_nodes(node, unused, cur_vis); end
  def check_new_visibility(node, unused, new_vis, cur_vis); end
  def check_node(node); end
  def check_scope(node); end
  def check_send_node(node, cur_vis, unused); end
  def class_or_instance_eval?(node = nil); end
  def class_or_module_or_struct_new_call?(node = nil); end
  def dynamic_method_definition?(node = nil); end
  def eval_call?(child); end
  def method_definition?(child); end
  def on_block(node); end
  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end
  def start_of_new_scope?(child); end
  def static_method_definition?(node = nil); end
end
class RuboCop::Cop::Lint::UselessAssignment < RuboCop::Cop::Cop
  def after_leaving_scope(scope, _variable_table); end
  def check_for_unused_assignments(variable); end
  def collect_variable_like_names(scope); end
  def join_force?(force_class); end
  def message_for_useless_assignment(assignment); end
  def message_specification(assignment, variable); end
  def multiple_assignment_message(variable_name); end
  def operator_assignment_message(scope, assignment); end
  def return_value_node_of_scope(scope); end
  def similar_name_message(variable); end
  def variable_like_method_invocation?(node); end
  include RuboCop::NameSimilarity
end
class RuboCop::Cop::Lint::UselessComparison < RuboCop::Cop::Cop
  def on_send(node); end
  def useless_comparison?(node = nil); end
end
class RuboCop::Cop::Lint::UselessElseWithoutRescue < RuboCop::Cop::Cop
  def alternative_message(_diagnostic); end
  def relevant_diagnostic?(diagnostic); end
  include RuboCop::Cop::ParserDiagnostic
end
class RuboCop::Cop::Lint::UselessSetterCall < RuboCop::Cop::Cop
  def last_expression(body); end
  def on_def(node); end
  def on_defs(node); end
  def setter_call_to_local_variable?(node = nil); end
end
class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end
  def contain_local_object?(variable_name); end
  def initialize(body_node); end
  def process_assignment(asgn_node, rhs_node); end
  def process_assignment_node(node); end
  def process_binary_operator_assignment(op_asgn_node); end
  def process_logical_operator_assignment(asgn_node); end
  def process_multiple_assignment(masgn_node); end
  def scan(node, &block); end
end
class RuboCop::Cop::Lint::Void < RuboCop::Cop::Cop
  def check_begin(node); end
  def check_defined(node); end
  def check_expression(expr); end
  def check_literal(node); end
  def check_nonmutating(node); end
  def check_self(node); end
  def check_var(node); end
  def check_void_op(node); end
  def in_void_context?(node); end
  def on_begin(node); end
  def on_block(node); end
  def on_kwbegin(node); end
end
module RuboCop::Cop::Metrics
end
class RuboCop::Cop::Metrics::CyclomaticComplexity < RuboCop::Cop::Cop
  def complexity_score_for(_node); end
  include RuboCop::Cop::MethodComplexity
end
module RuboCop::Cop::Metrics::Utils
end
class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def calculate; end
  def evaluate_branch_nodes(node); end
  def initialize(node); end
  def node_has_else_branch?(node); end
  def self.calculate(node); end
end
class RuboCop::Cop::Metrics::AbcSize < RuboCop::Cop::Cop
  def complexity(node); end
  include RuboCop::Cop::MethodComplexity
end
class RuboCop::Cop::Metrics::BlockLength < RuboCop::Cop::Cop
  def cop_label; end
  def excluded_method?(node); end
  def excluded_methods; end
  def on_block(node); end
  include RuboCop::Cop::TooManyLines
end
class RuboCop::Cop::Metrics::BlockNesting < RuboCop::Cop::Cop
  def check_nesting_level(node, max, current_level); end
  def consider_node?(node); end
  def count_blocks?; end
  def investigate(processed_source); end
  def message(max); end
  include RuboCop::Cop::ConfigurableMax
end
class RuboCop::Cop::Metrics::ClassLength < RuboCop::Cop::Cop
  def class_definition?(node = nil); end
  def message(length, max_length); end
  def on_casgn(node); end
  def on_class(node); end
  include RuboCop::Cop::ClassishLength
end
class RuboCop::Cop::Metrics::LineLength < RuboCop::Cop::Cop
  def allow_heredoc?; end
  def allow_uri?; end
  def allowed_heredoc; end
  def allowed_uri_position?(line, uri_range); end
  def autocorrect(range); end
  def breakable_nodes_by_line_index; end
  def breakable_range(line, line_index); end
  def breakable_semicolon_range(line, line_index); end
  def check_directive_line(line, line_index); end
  def check_for_breakable_node(node); end
  def check_line(line, line_index); end
  def check_uri_line(line, line_index); end
  def directive_on_source_line?(line_index); end
  def excess_range(uri_range, line, line_index); end
  def extract_heredocs(ast); end
  def find_excessive_uri_range(line); end
  def heredocs; end
  def highlight_start(line); end
  def ignore_cop_directives?; end
  def ignored_line?(line, line_index); end
  def indentation_difference(line); end
  def investigate_post_walk(processed_source); end
  def line_in_heredoc?(line_number); end
  def line_in_permitted_heredoc?(line_number); end
  def line_length(line); end
  def line_length_without_directive(line); end
  def match_uris(string); end
  def max; end
  def on_array(node); end
  def on_hash(node); end
  def on_potential_breakable_node(node); end
  def on_send(node); end
  def register_offense(loc, line, line_index); end
  def tab_indentation_width; end
  def uri_regexp; end
  def valid_uri?(uri_ish_string); end
  include RuboCop::Cop::CheckLineBreakable
  include RuboCop::Cop::ConfigurableMax
  include RuboCop::Cop::IgnoredPattern
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Metrics::MethodLength < RuboCop::Cop::Cop
  def cop_label; end
  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::TooManyLines
end
class RuboCop::Cop::Metrics::ModuleLength < RuboCop::Cop::Cop
  def message(length, max_length); end
  def module_definition?(node = nil); end
  def on_casgn(node); end
  def on_module(node); end
  include RuboCop::Cop::ClassishLength
end
class RuboCop::Cop::Metrics::ParameterLists < RuboCop::Cop::Cop
  def args_count(node); end
  def argument_to_lambda_or_proc?(node = nil); end
  def count_keyword_args?; end
  def max_params; end
  def message(node); end
  def on_args(node); end
  include RuboCop::Cop::ConfigurableMax
end
class RuboCop::Cop::Metrics::PerceivedComplexity < RuboCop::Cop::Cop
  def complexity_score_for(node); end
  include RuboCop::Cop::MethodComplexity
end
module RuboCop::Cop::Naming
end
class RuboCop::Cop::Naming::AccessorMethodName < RuboCop::Cop::Cop
  def bad_reader_name?(node); end
  def bad_writer_name?(node); end
  def message(node); end
  def on_def(node); end
  def on_defs(node); end
end
class RuboCop::Cop::Naming::AsciiIdentifiers < RuboCop::Cop::Cop
  def first_non_ascii_chars(string); end
  def first_offense_range(identifier); end
  def investigate(processed_source); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Naming::ClassAndModuleCamelCase < RuboCop::Cop::Cop
  def on_class(node); end
  def on_module(node); end
end
class RuboCop::Cop::Naming::ConstantName < RuboCop::Cop::Cop
  def allowed_assignment?(value); end
  def allowed_conditional_expression_on_rhs?(node); end
  def allowed_method_call_on_rhs?(node); end
  def class_or_struct_return_method?(node = nil); end
  def contains_contant?(node); end
  def literal_receiver?(node = nil); end
  def on_casgn(node); end
end
class RuboCop::Cop::Naming::FileName < RuboCop::Cop::Cop
  def allowed_acronyms; end
  def expect_matching_definition?; end
  def filename_good?(basename); end
  def find_class_or_module(node, namespace); end
  def for_bad_filename(file_path); end
  def ignore_executable_scripts?; end
  def investigate(processed_source); end
  def match?(expected); end
  def match_acronym?(expected, name); end
  def match_namespace(node, namespace, expected); end
  def no_definition_message(basename, file_path); end
  def other_message(basename); end
  def partial_matcher!(expected); end
  def regex; end
  def to_module_name(basename); end
  def to_namespace(path); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Naming::HeredocDelimiterCase < RuboCop::Cop::Cop
  def correct_case_delimiters?(node); end
  def correct_delimiters(node); end
  def message(_node); end
  def on_heredoc(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::Heredoc
end
class RuboCop::Cop::Naming::HeredocDelimiterNaming < RuboCop::Cop::Cop
  def blacklisted_delimiters; end
  def meaningful_delimiters?(node); end
  def on_heredoc(node); end
  include RuboCop::Cop::Heredoc
end
class RuboCop::Cop::Naming::MemoizedInstanceVariableName < RuboCop::Cop::Cop
  def matches?(method_name, ivar_assign); end
  def memoized?(node = nil); end
  def message(variable); end
  def on_def(node); end
  def on_defs(node); end
  def self.node_pattern; end
  def style_parameter_name; end
  def suggested_var(method_name); end
  def variable_name_candidates(method_name); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Naming::MethodName < RuboCop::Cop::Cop
  def message(style); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::ConfigurableNaming
end
class RuboCop::Cop::Naming::BinaryOperatorParameterName < RuboCop::Cop::Cop
  def on_def(node); end
  def op_method?(name); end
  def op_method_candidate?(node = nil); end
end
class RuboCop::Cop::Naming::PredicateName < RuboCop::Cop::Cop
  def allowed_method_name?(method_name, prefix); end
  def dynamic_method_define(node = nil); end
  def expected_name(method_name, prefix); end
  def message(method_name, new_name); end
  def method_definition_macros(macro_name); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def predicate_prefixes; end
  def predicate_whitelist; end
  def prefix_blacklist; end
end
class RuboCop::Cop::Naming::RescuedExceptionsVariableName < RuboCop::Cop::Cop
  def autocorrect(node); end
  def location; end
  def message(_node = nil); end
  def offense_range(resbody); end
  def on_resbody(node); end
  def preferred_name; end
  def variable_name; end
end
class RuboCop::Cop::Naming::UncommunicativeBlockParamName < RuboCop::Cop::Cop
  def on_block(node); end
  include RuboCop::Cop::UncommunicativeName
end
class RuboCop::Cop::Naming::UncommunicativeMethodParamName < RuboCop::Cop::Cop
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::UncommunicativeName
end
class RuboCop::Cop::Naming::VariableName < RuboCop::Cop::Cop
  def message(style); end
  def on_arg(node); end
  def on_blockarg(node); end
  def on_cvasgn(node); end
  def on_ivasgn(node); end
  def on_kwarg(node); end
  def on_kwoptarg(node); end
  def on_kwrestarg(node); end
  def on_lvasgn(node); end
  def on_optarg(node); end
  def on_restarg(node); end
  include RuboCop::Cop::ConfigurableNaming
end
class RuboCop::Cop::Naming::VariableNumber < RuboCop::Cop::Cop
  def message(style); end
  def on_arg(node); end
  def on_cvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  include RuboCop::Cop::ConfigurableNumbering
end
class RuboCop::Cop::Style::AccessModifierDeclarations < RuboCop::Cop::Cop
  def access_modifier_is_inlined?(node); end
  def access_modifier_is_not_inlined?(node); end
  def group_style?; end
  def inline_style?; end
  def message(node); end
  def offense?(node); end
  def on_send(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::Alias < RuboCop::Cop::Cop
  def add_offense_for_args(node); end
  def alias_keyword_possible?(node); end
  def alias_method_possible?(node); end
  def autocorrect(node); end
  def bareword?(sym_node); end
  def correct_alias_method_to_alias(send_node); end
  def correct_alias_to_alias_method(node); end
  def correct_alias_with_symbol_args(node); end
  def identifier(node = nil); end
  def lexical_scope_type(node); end
  def on_alias(node); end
  def on_send(node); end
  def scope_type(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::AndOr < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_not(node, receiver, corrector); end
  def correct_other(node, corrector); end
  def correct_send(node, corrector); end
  def correct_setter(node, corrector); end
  def correctable_send?(node); end
  def message(node); end
  def on_and(node); end
  def on_conditionals(node); end
  def on_if(node); end
  def on_or(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end
  def process_logical_operator(node); end
  def whitespace_before_arg(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::ArrayJoin < RuboCop::Cop::Cop
  def autocorrect(node); end
  def join_candidate?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Style::AsciiComments < RuboCop::Cop::Cop
  def allowed_non_ascii_chars; end
  def first_non_ascii_chars(string); end
  def first_offense_range(comment); end
  def investigate(processed_source); end
  def only_allowed_non_ascii_chars?(string); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::Attr < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_send(node); end
  def replacement_method(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::AutoResourceCleanup < RuboCop::Cop::Cop
  def cleanup?(node); end
  def on_send(node); end
end
class RuboCop::Cop::Style::BarePercentLiterals < RuboCop::Cop::Cop
  def add_offense_for_wrong_style(node, good, bad); end
  def autocorrect(node); end
  def check(node); end
  def on_dstr(node); end
  def on_str(node); end
  def requires_bare_percent?(source); end
  def requires_percent_q?(source); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::BeginBlock < RuboCop::Cop::Cop
  def on_preexe(node); end
end
class RuboCop::Cop::Style::BlockComments < RuboCop::Cop::Cop
  def autocorrect(comment); end
  def eq_end_part(comment, expr); end
  def investigate(processed_source); end
  def parts(comment); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::BlockDelimiters < RuboCop::Cop::Cop
  def array_or_range?(node); end
  def autocorrect(node); end
  def braces_for_chaining_message(node); end
  def braces_for_chaining_style?(node); end
  def braces_style?(node); end
  def conditional?(node); end
  def correction_would_break_code?(node); end
  def functional_block?(node); end
  def functional_method?(method_name); end
  def get_blocks(node, &block); end
  def line_count_based_block_style?(node); end
  def line_count_based_message(node); end
  def message(node); end
  def on_block(node); end
  def on_send(node); end
  def procedural_method?(method_name); end
  def procedural_oneliners_may_have_braces?; end
  def proper_block_style?(node); end
  def replace_braces_with_do_end(loc); end
  def replace_do_end_with_braces(loc); end
  def return_value_of_scope?(node); end
  def return_value_used?(node); end
  def semantic_block_style?(node); end
  def semantic_message(node); end
  def whitespace_after?(range, length = nil); end
  def whitespace_before?(range); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::IgnoredMethods
end
class RuboCop::Cop::Style::BracesAroundHashParameters < RuboCop::Cop::Cop
  def add_arg_offense(arg, type); end
  def add_braces(corrector, node); end
  def autocorrect(send_node); end
  def check(arg, args); end
  def check_context_dependent(arg, args); end
  def extra_left_space?(hash_node); end
  def extra_right_space?(hash_node); end
  def extra_space(hash_node); end
  def left_brace_and_space(loc_begin, space); end
  def left_whole_line_range(loc_begin); end
  def on_csend(node); end
  def on_send(node); end
  def remove_braces_with_range(corrector, left_range, right_range); end
  def remove_braces_with_whitespace(corrector, node, space); end
  def right_brace_and_space(loc_end, space); end
  def right_whole_line_range(loc_end); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::CaseEquality < RuboCop::Cop::Cop
  def case_equality?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Style::CharacterLiteral < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_style_detected; end
  def offense?(node); end
  def opposite_style_detected; end
  include RuboCop::Cop::StringHelp
end
class RuboCop::Cop::Style::ClassAndModuleChildren < RuboCop::Cop::Cop
  def add_trailing_end(corrector, node, padding); end
  def autocorrect(node); end
  def check_compact_style(node, body); end
  def check_nested_style(node); end
  def check_style(node, body); end
  def compact_definition(corrector, node); end
  def compact_identifier_name(node); end
  def compact_node(corrector, node); end
  def compact_node_name?(node); end
  def indent_width; end
  def leading_spaces(node); end
  def nest_definition(corrector, node); end
  def nest_or_compact(corrector, node); end
  def on_class(node); end
  def on_module(node); end
  def one_child?(body); end
  def remove_end(corrector, body); end
  def replace_keyword_with_module(corrector, node); end
  def split_on_double_colon(corrector, node, padding); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::ClassCheck < RuboCop::Cop::Cop
  def autocorrect(node); end
  def class_check?(node = nil); end
  def message(node); end
  def on_send(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::ClassMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_defs(name, node); end
  def message(node); end
  def on_class(node); end
  def on_module(node); end
end
class RuboCop::Cop::Style::ClassVars < RuboCop::Cop::Cop
  def message(node); end
  def on_cvasgn(node); end
end
class RuboCop::Cop::Style::CollectionMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_method_node(node); end
  def message(node); end
  def on_block(node); end
  def on_send(node); end
  include RuboCop::Cop::MethodPreference
end
class RuboCop::Cop::Style::ColonMethodCall < RuboCop::Cop::Cop
  def autocorrect(node); end
  def java_type_node?(node = nil); end
  def on_send(node); end
  def self.autocorrect_incompatible_with; end
end
class RuboCop::Cop::Style::ColonMethodDefinition < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_defs(node); end
end
class RuboCop::Cop::Style::CommandLiteral < RuboCop::Cop::Cop
  def allow_inner_backticks?; end
  def allowed_backtick_literal?(node); end
  def allowed_percent_x_literal?(node); end
  def autocorrect(node); end
  def backtick_literal?(node); end
  def check_backtick_literal(node); end
  def check_percent_x_literal(node); end
  def command_delimiter; end
  def contains_backtick?(node); end
  def contains_disallowed_backtick?(node); end
  def default_delimiter; end
  def message(node); end
  def node_body(node); end
  def on_xstr(node); end
  def preferred_delimiter; end
  def preferred_delimiters_config; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::CommentAnnotation < RuboCop::Cop::Cop
  def annotation_range(comment, margin, length); end
  def autocorrect(comment); end
  def concat_length(*args); end
  def correct_annotation?(first_word, colon, space, note); end
  def first_comment_line?(comments, index); end
  def inline_comment?(comment); end
  def investigate(processed_source); end
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::Style::AnnotationComment
end
class RuboCop::Cop::Style::CommentedKeyword < RuboCop::Cop::Cop
  def extract_heredoc_lines(ast); end
  def investigate(processed_source); end
  def message(node); end
  def offensive?(line); end
  include RuboCop::Cop::RangeHelp
end
module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def assignment_rhs_exist?(node); end
  def end_with_eq?(sym); end
  def expand_elses(branch); end
  def expand_elsif(node, elsif_branches = nil); end
  def expand_when_branches(when_branches); end
  def indent(cop, source); end
  def lhs(node); end
  def lhs_for_send(node); end
  def setter_method?(method_name); end
  def tail(branch); end
  extend RuboCop::NodePattern::Macros
end
class RuboCop::Cop::Style::ConditionalAssignment < RuboCop::Cop::Cop
  def allowed_single_line?(branches); end
  def allowed_statements?(branches); end
  def allowed_ternary?(assignment); end
  def assignment_node(node); end
  def assignment_type?(node = nil); end
  def assignment_types_match?(*nodes); end
  def autocorrect(node); end
  def candidate_condition?(node = nil); end
  def candidate_node?(node); end
  def check_assignment_to_condition(node); end
  def check_node(node, branches); end
  def condition?(node = nil); end
  def correction_exceeds_line_limit?(node, branches); end
  def include_ternary?; end
  def indentation_width; end
  def lhs_all_match?(branches); end
  def line_length_cop_enabled?; end
  def longest_line(node, assignment); end
  def longest_line_exceeds_line_limit?(node, assignment); end
  def max_line_length; end
  def move_assignment_inside_condition(node); end
  def move_assignment_outside_condition(node); end
  def on_and_asgn(node); end
  def on_case(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_if(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
  def on_send(node); end
  def single_line_conditions_only?; end
  def ternary_condition?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::IgnoredNode
  include RuboCop::Cop::Style::ConditionalAssignmentHelper
end
module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end
  def correct_branches(corrector, branches); end
  def correct_if_branches(corrector, cop, node); end
  def remove_whitespace_in_branches(corrector, branch, condition, column); end
  def replace_branch_assignment(corrector, branch); end
  def white_space_range(node, column); end
end
class RuboCop::Cop::Style::TernaryCorrector
  def self.correct(node); end
  def self.correction(node); end
  def self.element_assignment?(node); end
  def self.extract_branches(node); end
  def self.move_assignment_inside_condition(node); end
  def self.move_branch_inside_condition(corrector, branch, assignment); end
  def self.remove_parentheses(corrector, node); end
  def self.ternary(node); end
end
class RuboCop::Cop::Style::IfCorrector
  def self.correct(cop, node); end
  def self.extract_tail_branches(node); end
  def self.move_assignment_inside_condition(node); end
  def self.move_branch_inside_condition(corrector, branch, condition, assignment, column); end
end
class RuboCop::Cop::Style::CaseCorrector
  def self.correct(cop, node); end
  def self.extract_branches(case_node); end
  def self.extract_tail_branches(node); end
  def self.move_assignment_inside_condition(node); end
  def self.move_branch_inside_condition(corrector, branch, condition, assignment, column); end
end
class RuboCop::Cop::Style::ConstantVisibility < RuboCop::Cop::Cop
  def class_or_module_scope?(node); end
  def message(node); end
  def on_casgn(node); end
  def visibility_declaration?(node); end
  def visibility_declaration_for?(node = nil, param1); end
end
class RuboCop::Cop::Style::Copyright < RuboCop::Cop::Cop
  def autocorrect(token); end
  def autocorrect_notice; end
  def encoding_token?(processed_source, token_index); end
  def insert_notice_before(processed_source); end
  def investigate(processed_source); end
  def notice; end
  def notice_found?(processed_source); end
  def shebang_token?(processed_source, token_index); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::DateTime < RuboCop::Cop::Cop
  def date_time?(node = nil); end
  def disallow_coercion?; end
  def historic_date?(node = nil); end
  def on_send(node); end
  def to_datetime?(node = nil); end
end
class RuboCop::Cop::Style::DefWithParentheses < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
end
class RuboCop::Cop::Style::Dir < RuboCop::Cop::Cop
  def autocorrect(node); end
  def dir_replacement?(node = nil); end
  def file_keyword?(node); end
  def on_send(node); end
end
class RuboCop::Cop::Style::DocumentationMethod < RuboCop::Cop::Cop
  def check(node); end
  def module_function_node?(node = nil); end
  def on_def(node); end
  def on_defs(node); end
  def require_for_non_public_methods?; end
  include RuboCop::Cop::DefNode
  include RuboCop::Cop::DocumentationComment
end
class RuboCop::Cop::Style::Documentation < RuboCop::Cop::Cop
  def check(node, body, type); end
  def compact_namespace?(node); end
  def constant_definition?(node = nil); end
  def namespace?(node); end
  def nodoc(node); end
  def nodoc?(comment, require_all = nil); end
  def nodoc_comment?(node, require_all = nil); end
  def on_class(node); end
  def on_module(node); end
  def outer_module(node0); end
  include RuboCop::Cop::DocumentationComment
end
class RuboCop::Cop::Style::DoubleNegation < RuboCop::Cop::Cop
  def double_negative?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Style::EachForSimpleLoop < RuboCop::Cop::Cop
  def autocorrect(node); end
  def offending_each_range(node = nil); end
  def on_block(node); end
end
class RuboCop::Cop::Style::EachWithObject < RuboCop::Cop::Cop
  def accumulator_param_assigned_to?(body, args); end
  def autocorrect(node); end
  def each_with_object_candidate?(node = nil); end
  def first_argument_returned?(args, return_value); end
  def on_block(node); end
  def return_value(body); end
  def return_value_occupies_whole_line?(node); end
  def simple_method_arg?(method_arg); end
  def whole_line_expression(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EmptyBlockParameter < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_block(node); end
  include RuboCop::Cop::EmptyParameter
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EmptyCaseCondition < RuboCop::Cop::Cop
  def autocorrect(case_node); end
  def correct_case_when(corrector, case_node, when_nodes); end
  def correct_when_conditions(corrector, when_nodes); end
  def keep_first_when_comment(case_node, first_when_node, corrector); end
  def on_case(case_node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EmptyElse < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_forbidden?(type); end
  def base_node(node); end
  def check(node); end
  def comment_in_else?(node); end
  def else_line_range(loc); end
  def empty_check(node); end
  def empty_style?; end
  def missing_else_style; end
  def nil_check(node); end
  def nil_style?; end
  def on_case(node); end
  def on_normal_if_unless(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::OnNormalIfUnless
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EmptyLambdaParameter < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_block(node); end
  include RuboCop::Cop::EmptyParameter
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EmptyLiteral < RuboCop::Cop::Cop
  def array_node(node = nil); end
  def array_with_block(node = nil); end
  def autocorrect(node); end
  def correction(node); end
  def enforce_double_quotes?; end
  def first_argument_unparenthesized?(node); end
  def hash_node(node = nil); end
  def hash_with_block(node = nil); end
  def offense_array_node?(node); end
  def offense_hash_node?(node); end
  def on_send(node); end
  def preferred_string_literal; end
  def replacement_range(node); end
  def str_node(node = nil); end
  def string_literals_config; end
  include RuboCop::Cop::FrozenStringLiteral
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EmptyMethod < RuboCop::Cop::Cop
  def autocorrect(node); end
  def comment_lines?(node); end
  def compact?(node); end
  def compact_style?; end
  def correct_style?(node); end
  def corrected(node); end
  def expanded?(node); end
  def expanded_style?; end
  def joint(node); end
  def message(_node); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::Encoding < RuboCop::Cop::Cop
  def autocorrect(range); end
  def encoding_line_number(processed_source); end
  def encoding_omitable?(line); end
  def investigate(processed_source); end
  def offense(processed_source, line_number); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::EndBlock < RuboCop::Cop::Cop
  def on_postexe(node); end
end
class RuboCop::Cop::Style::EvalWithLocation < RuboCop::Cop::Cop
  def add_offense_for_different_line(node, line_node, line_diff); end
  def add_offense_for_same_line(node, line_node); end
  def eval_without_location?(node = nil); end
  def line_with_offset?(node = nil, param1, param2); end
  def message_incorrect_line(actual, sign, line_diff); end
  def on_send(node); end
  def on_with_lineno(node, code); end
  def special_file_keyword?(node); end
  def special_line_keyword?(node); end
  def string_first_line(str_node); end
  def with_lineno?(node); end
end
class RuboCop::Cop::Style::EvenOdd < RuboCop::Cop::Cop
  def autocorrect(node); end
  def even_odd_candidate?(node = nil); end
  def on_send(node); end
  def replacement_method(arg, method); end
end
class RuboCop::Cop::Style::ExpandPathArguments < RuboCop::Cop::Cop
  def arguments_range(node); end
  def autocorrect(node); end
  def autocorrect_expand_path(corrector, current_path, default_dir); end
  def depth(current_path); end
  def file_expand_path(node = nil); end
  def inspect_offense_for_expand_path(node, current_path, default_dir); end
  def on_send(node); end
  def parent_path(current_path); end
  def pathname_new_parent_expand_path(node = nil); end
  def pathname_parent_expand_path(node = nil); end
  def remove_parent_method(corrector, default_dir); end
  def strip_surrounded_quotes!(path_string); end
  def unrecommended_argument?(default_dir); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::For < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_block(node); end
  def on_for(node); end
  def suspect_enumerable?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::FormatString < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_from_percent(corrector, node); end
  def autocorrect_to_percent(corrector, node); end
  def formatter(node = nil); end
  def message(detected_style); end
  def method_name(style_name); end
  def on_send(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::FormatStringToken < RuboCop::Cop::Cop
  def includes_format_methods?(node); end
  def match_token(source_range); end
  def message(detected_style); end
  def message_text(style); end
  def on_str(node); end
  def placeholder_argument?(node); end
  def slice_source(source_range, new_begin, new_end); end
  def split_token(source_range, match_begin, match_end); end
  def str_contents(source_map); end
  def token_ranges(contents); end
  def tokens(str_node, &block); end
  def unannotated_format?(node, detected_style); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::FrozenStringLiteralComment < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_for_comment(processed_source); end
  def check_for_no_comment(processed_source); end
  def correction_range; end
  def frozen_string_literal_comment(processed_source); end
  def insert_comment(corrector); end
  def investigate(processed_source); end
  def last_special_comment(processed_source); end
  def offense(processed_source); end
  def preceding_comment; end
  def proceeding_comment; end
  def remove_comment(corrector, node); end
  def unnecessary_comment_offense(processed_source); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::FrozenStringLiteral
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::GlobalVars < RuboCop::Cop::Cop
  def allowed_var?(global_var); end
  def check(node); end
  def on_gvar(node); end
  def on_gvasgn(node); end
  def user_vars; end
end
class RuboCop::Cop::Style::GuardClause < RuboCop::Cop::Cop
  def accepted_form?(node, ending = nil); end
  def accepted_if?(node, ending); end
  def check_ending_if(node); end
  def contains_guard_clause?(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_if(node); end
  include RuboCop::Cop::MinBodyLength
end
class RuboCop::Cop::Style::HashSyntax < RuboCop::Cop::Cop
  def acceptable_19_syntax_symbol?(sym_name); end
  def alternative_style; end
  def argument_without_space?(node); end
  def autocorrect(node); end
  def autocorrect_hash_rockets(corrector, pair_node); end
  def autocorrect_no_mixed_keys(corrector, pair_node); end
  def autocorrect_ruby19(corrector, pair_node); end
  def check(pairs, delim, msg); end
  def force_hash_rockets?(pairs); end
  def hash_rockets_check(pairs); end
  def no_mixed_keys_check(pairs); end
  def on_hash(node); end
  def ruby19_check(pairs); end
  def ruby19_no_mixed_keys_check(pairs); end
  def sym_indices?(pairs); end
  def word_symbol_pair?(pair); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::IdenticalConditionalBranches < RuboCop::Cop::Cop
  def check_branches(branches); end
  def check_expressions(expressions); end
  def expand_elses(branch); end
  def head(node); end
  def message(node); end
  def on_case(node); end
  def on_if(node); end
  def tail(node); end
end
class RuboCop::Cop::Style::IfInsideElse < RuboCop::Cop::Cop
  def on_if(node); end
end
class RuboCop::Cop::Style::IfUnlessModifier < RuboCop::Cop::Cop
  def autocorrect(node); end
  def eligible_node?(node); end
  def first_line_comment(node); end
  def named_capture_in_condition?(node); end
  def non_eligible_if?(node); end
  def on_if(node); end
  def parenthesize?(node); end
  def to_modifier_form(node); end
  include RuboCop::Cop::StatementModifier
end
class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless < RuboCop::Cop::Cop
  def on_if(node); end
  include RuboCop::Cop::StatementModifier
end
class RuboCop::Cop::Style::IfWithSemicolon < RuboCop::Cop::Cop
  def on_normal_if_unless(node); end
  include RuboCop::Cop::OnNormalIfUnless
end
class RuboCop::Cop::Style::ImplicitRuntimeError < RuboCop::Cop::Cop
  def implicit_runtime_error_raise_or_fail(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Style::InfiniteLoop < RuboCop::Cop::Cop
  def after_leaving_scope(scope, _variable_table); end
  def assigned_before_loop?(var, range); end
  def assigned_inside_loop?(var, range); end
  def autocorrect(node); end
  def configured_indent; end
  def join_force?(force_class); end
  def modifier_replacement(node); end
  def non_modifier_range(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end
  def referenced_after_loop?(var, range); end
  def replace_begin_end_with_modifier(node); end
  def replace_source(range, replacement); end
  def while_or_until(node); end
end
class RuboCop::Cop::Style::InverseMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def camel_case_constant?(node); end
  def correct_inverse_block(node); end
  def correct_inverse_selector(block, corrector); end
  def dot_range(loc); end
  def end_parentheses(node, method_call); end
  def inverse_block?(node = nil); end
  def inverse_blocks; end
  def inverse_candidate?(node = nil); end
  def inverse_methods; end
  def negated?(node); end
  def not_to_receiver(node, method_call); end
  def on_block(node); end
  def on_send(node); end
  def possible_class_hierarchy_check?(lhs, rhs, method); end
  def self.autocorrect_incompatible_with; end
  include RuboCop::Cop::IgnoredNode
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::InlineComment < RuboCop::Cop::Cop
  def investigate(processed_source); end
end
class RuboCop::Cop::Style::IpAddresses < RuboCop::Cop::Cop
  def correct_style_detected; end
  def could_be_ip?(str); end
  def offense?(node); end
  def opposite_style_detected; end
  def starts_with_hex_or_colon?(str); end
  def too_long?(str); end
  def whitelist; end
  include RuboCop::Cop::StringHelp
end
class RuboCop::Cop::Style::Lambda < RuboCop::Cop::Cop
  def arguments_with_whitespace(node); end
  def autocorrect(node); end
  def autocorrect_method_to_literal(corrector, node); end
  def lambda_arg_string(args); end
  def lambda_node?(node = nil); end
  def message(node, selector); end
  def message_line_modifier(node); end
  def offending_selector?(node, selector); end
  def on_block(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::LambdaCall < RuboCop::Cop::Cop
  def add_parentheses(node, corrector); end
  def args_begin(node); end
  def args_end(node); end
  def autocorrect(node); end
  def explicit_style?; end
  def implicit_style?; end
  def message(_node); end
  def offense?(node); end
  def on_send(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::LineEndConcatenation < RuboCop::Cop::Cop
  def autocorrect(operator_range); end
  def check_token_set(index); end
  def eligible_next_successor?(next_successor); end
  def eligible_operator?(operator); end
  def eligible_predecessor?(predecessor); end
  def eligible_successor?(successor); end
  def investigate(processed_source); end
  def self.autocorrect_incompatible_with; end
  def standard_string_literal?(token); end
  def token_after_last_string(successor, base_index); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses < RuboCop::Cop::Cop
  def any_assignment?(node); end
  def autocorrect(node); end
  def ineligible_node?(node); end
  def on_send(node); end
  def same_name_assignment?(node); end
  def variable_in_mass_assignment?(variable_name, node); end
  include RuboCop::Cop::IgnoredMethods
end
class RuboCop::Cop::Style::MethodCallWithArgsParentheses < RuboCop::Cop::Cop
  def add_offense_for_omit_parentheses(node); end
  def add_offense_for_require_parentheses(node); end
  def allowed_camel_case_method_call?(node); end
  def allowed_chained_call_with_parentheses?(node); end
  def allowed_multiline_call_with_parentheses?(node); end
  def ambigious_literal?(node); end
  def args_begin(node); end
  def args_end(node); end
  def args_parenthesized?(node); end
  def assigned_before?(node, target); end
  def autocorrect(node); end
  def autocorrect_for_omit_parentheses(node); end
  def autocorrect_for_require_parentheses(node); end
  def call_as_argument_or_chain?(node); end
  def call_in_literals?(node); end
  def call_in_logical_operators?(node); end
  def call_in_optional_arguments?(node); end
  def call_with_ambiguous_arguments?(node); end
  def call_with_braced_block?(node); end
  def eligible_for_parentheses_omission?(node); end
  def hash_literal?(node); end
  def hash_literal_in_arguments?(node); end
  def ignored_macro?(node); end
  def included_macros_list; end
  def legitimate_call_with_parentheses?(node); end
  def logical_operator?(node); end
  def message(_node = nil); end
  def on_csend(node); end
  def on_send(node); end
  def on_super(node); end
  def on_yield(node); end
  def parentheses_at_the_end_of_multiline_call?(node); end
  def regexp_slash_literal?(node); end
  def splat?(node); end
  def super_call_without_arguments?(node); end
  def ternary_if?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::IgnoredMethodPatterns
  include RuboCop::Cop::IgnoredMethods
end
class RuboCop::Cop::Style::MethodCalledOnDoEndBlock < RuboCop::Cop::Cop
  def on_block(node); end
  def on_csend(node); end
  def on_send(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::MethodDefParentheses < RuboCop::Cop::Cop
  def arguments_without_parentheses?(node); end
  def autocorrect(node); end
  def missing_parentheses(node); end
  def on_def(node); end
  def on_defs(node); end
  def require_parentheses?(args); end
  def unwanted_parentheses(args); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::MethodMissingSuper < RuboCop::Cop::Cop
  def on_def(node); end
  def on_defs(node); end
end
class RuboCop::Cop::Style::MinMax < RuboCop::Cop::Cop
  def argument_range(node); end
  def autocorrect(node); end
  def message(offender, receiver); end
  def min_max_candidate(node = nil); end
  def offending_range(node); end
  def on_array(node); end
  def on_return(node); end
end
class RuboCop::Cop::Style::MissingElse < RuboCop::Cop::Cop
  def case_style?; end
  def check(node); end
  def empty_else_config; end
  def empty_else_cop_enabled?; end
  def empty_else_style; end
  def if_style?; end
  def message(node); end
  def on_case(node); end
  def on_normal_if_unless(node); end
  def unless_else_config; end
  def unless_else_cop_enabled?; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::OnNormalIfUnless
end
class RuboCop::Cop::Style::MissingRespondToMissing < RuboCop::Cop::Cop
  def implements_respond_to_missing?(node); end
  def on_def(node); end
  def on_defs(node); end
end
class RuboCop::Cop::Style::MixinGrouping < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(send_node); end
  def check_grouped_style(send_node); end
  def check_separated_style(send_node); end
  def group_mixins(node, mixins); end
  def grouped_style?; end
  def indent(node); end
  def message(send_node); end
  def on_class(node); end
  def on_module(node); end
  def range_to_remove_for_subsequent_mixin(mixins, node); end
  def separate_mixins(node); end
  def separated_style?; end
  def sibling_mixins(send_node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::MixinUsage < RuboCop::Cop::Cop
  def accepted_include?(node); end
  def belongs_to_class_or_module?(node); end
  def include_statement(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Style::ModuleFunction < RuboCop::Cop::Cop
  def autocorrect(node); end
  def each_wrong_style(nodes); end
  def extend_self_node?(node = nil); end
  def message(_node); end
  def module_function_node?(node = nil); end
  def on_module(node); end
  def private_directive?(node = nil); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::MultilineBlockChain < RuboCop::Cop::Cop
  def on_block(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::MultilineIfThen < RuboCop::Cop::Cop
  def autocorrect(node); end
  def non_modifier_then?(node); end
  def on_normal_if_unless(node); end
  include RuboCop::Cop::OnNormalIfUnless
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::MultilineIfModifier < RuboCop::Cop::Cop
  def autocorrect(node); end
  def configured_indentation_width; end
  def indented_body(body, node); end
  def message(node); end
  def on_if(node); end
  def to_normal_if(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::StatementModifier
end
class RuboCop::Cop::Style::MultilineMethodSignature < RuboCop::Cop::Cop
  def closing_line(node); end
  def correction_exceeds_max_line_length?(node); end
  def definition_width(node); end
  def indentation_width(node); end
  def max_line_length; end
  def on_def(node); end
  def on_defs(node); end
  def opening_line(node); end
end
class RuboCop::Cop::Style::MultilineMemoization < RuboCop::Cop::Cop
  def autocorrect(node); end
  def bad_rhs?(rhs); end
  def keyword_autocorrect(node, corrector); end
  def keyword_begin_str(node, node_buf); end
  def keyword_end_str(node, node_buf); end
  def on_or_asgn(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::MultilineTernaryOperator < RuboCop::Cop::Cop
  def on_if(node); end
end
class RuboCop::Cop::Style::MultipleComparison < RuboCop::Cop::Cop
  def comparison?(node); end
  def nested_comparison?(node); end
  def nested_variable_comparison?(node); end
  def on_or(node); end
  def root_of_or_node(or_node); end
  def simple_comparison?(node = nil); end
  def simple_double_comparison?(node = nil); end
  def variable_name(node); end
  def variables_in_node(node); end
  def variables_in_simple_node(node); end
end
class RuboCop::Cop::Style::MutableConstant < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(value); end
  def correct_splat_expansion(corrector, expr, splat_value); end
  def frozen_string_literal?(node); end
  def immutable_literal?(node); end
  def mutable_literal?(value); end
  def on_assignment(value); end
  def on_casgn(node); end
  def on_or_asgn(node); end
  def operation_produces_immutable_object?(node = nil); end
  def range_enclosed_in_parentheses?(node = nil); end
  def requires_parentheses?(node); end
  def splat_value(node = nil); end
  def strict_check(value); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::FrozenStringLiteral
end
class RuboCop::Cop::Style::NegatedIf < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_style?(node); end
  def message(node); end
  def on_if(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::NegativeConditional
end
class RuboCop::Cop::Style::NegatedUnless < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_style?(node); end
  def message(node); end
  def on_if(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::NegativeConditional
end
class RuboCop::Cop::Style::NegatedWhile < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_until(node); end
  def on_while(node); end
  include RuboCop::Cop::NegativeConditional
end
class RuboCop::Cop::Style::NestedModifier < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def left_hand_operand(node, operator); end
  def modifier?(node); end
  def new_expression(outer_node, inner_node); end
  def on_if(node); end
  def on_until(node); end
  def on_while(node); end
  def replacement_operator(keyword); end
  def requires_parens?(node); end
  def right_hand_operand(node, left_hand_keyword); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::NestedParenthesizedCalls < RuboCop::Cop::Cop
  def allowed_omission?(send_node); end
  def autocorrect(nested); end
  def on_csend(node); end
  def on_send(node); end
  def whitelisted?(send_node); end
  def whitelisted_methods; end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::NestedTernaryOperator < RuboCop::Cop::Cop
  def on_if(node); end
end
class RuboCop::Cop::Style::Next < RuboCop::Cop::Cop
  def actual_indent(lines, buffer); end
  def allowed_modifier_if?(node); end
  def autocorrect(node); end
  def autocorrect_block(corrector, node); end
  def autocorrect_modifier(corrector, node); end
  def check(node); end
  def cond_range(node, cond); end
  def end_followed_by_whitespace_only?(source_buffer, end_pos); end
  def end_range(node); end
  def ends_with_condition?(body); end
  def exit_body_type?(node); end
  def heredoc_lines(node); end
  def if_else_children?(node); end
  def if_without_else?(node); end
  def investigate(_processed_source); end
  def offense_location(offense_node); end
  def offense_node(body); end
  def on_block(node); end
  def on_for(node); end
  def on_until(node); end
  def on_while(node); end
  def reindent(lines, node, corrector); end
  def reindent_line(corrector, lineno, delta, buffer); end
  def reindentable_lines(node); end
  def self.autocorrect_incompatible_with; end
  def simple_if_without_break?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::MinBodyLength
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::NilComparison < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(_node); end
  def nil_check?(node = nil); end
  def nil_comparison?(node = nil); end
  def on_send(node); end
  def prefer_comparison?; end
  def style_check?(node, &block); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::NonNilCheck < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_comparison(node); end
  def autocorrect_non_nil(node, inner_node); end
  def autocorrect_unless_nil(node, receiver); end
  def include_semantic_changes?; end
  def message(node); end
  def nil_check?(node = nil); end
  def not_and_nil_check?(node = nil); end
  def not_equal_to_nil?(node = nil); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def unless_and_nil_check?(send_node); end
  def unless_check?(node = nil); end
end
class RuboCop::Cop::Style::Not < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_opposite_method(range, child); end
  def correct_with_parens(range, node); end
  def correct_without_parens(range); end
  def on_send(node); end
  def opposite_method?(child); end
  def requires_parens?(child); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::NumericLiterals < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def format_int_part(int_part); end
  def format_number(node); end
  def max_parameter_name; end
  def min_digits; end
  def on_float(node); end
  def on_int(node); end
  def short_group_regex; end
  include RuboCop::Cop::ConfigurableMax
  include RuboCop::Cop::IntegerNode
end
class RuboCop::Cop::Style::NumericLiteralPrefix < RuboCop::Cop::Cop
  def autocorrect(node); end
  def format_binary(source); end
  def format_decimal(source); end
  def format_hex(source); end
  def format_octal(source); end
  def format_octal_zero_only(source); end
  def hex_bin_dec_literal_type(literal); end
  def literal_type(node); end
  def message(node); end
  def octal_literal_type(literal); end
  def octal_zero_only?; end
  def on_int(node); end
  include RuboCop::Cop::IntegerNode
end
class RuboCop::Cop::Style::NumericPredicate < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def comparison(node = nil); end
  def invert; end
  def inverted_comparison(node = nil); end
  def on_send(node); end
  def parenthesized_source(node); end
  def predicate(node = nil); end
  def replacement(numeric, operation); end
  def require_parentheses?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::IgnoredMethods
end
class RuboCop::Cop::Style::OneLineConditional < RuboCop::Cop::Cop
  def autocorrect(node); end
  def expr_replacement(node); end
  def keyword_with_changed_precedence?(node); end
  def message(node); end
  def method_call_with_changed_precedence?(node); end
  def on_normal_if_unless(node); end
  def replacement(node); end
  def requires_parentheses?(node); end
  def to_ternary(node); end
  include RuboCop::Cop::OnNormalIfUnless
end
class RuboCop::Cop::Style::OrAssignment < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_if(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def take_variable_and_default_from_ternary(node); end
  def take_variable_and_default_from_unless(node); end
  def ternary_assignment?(node = nil); end
  def unless_assignment?(node = nil); end
end
class RuboCop::Cop::Style::OptionHash < RuboCop::Cop::Cop
  def on_args(node); end
  def option_hash(node = nil); end
  def super_used?(node); end
  def suspicious_name?(arg_name); end
  def whitelist; end
end
class RuboCop::Cop::Style::OptionalArguments < RuboCop::Cop::Cop
  def argument_positions(arguments); end
  def each_misplaced_optional_arg(arguments); end
  def on_def(node); end
end
class RuboCop::Cop::Style::ParallelAssignment < RuboCop::Cop::Cop
  def add_self_to_getters(right_elements); end
  def allowed_lhs?(node); end
  def allowed_masign?(lhs_elements, rhs_elements); end
  def allowed_rhs?(node); end
  def assignment_corrector(node, order); end
  def autocorrect(node); end
  def find_valid_order(left_elements, right_elements); end
  def implicit_self_getter?(node = nil); end
  def modifier_statement?(node); end
  def on_masgn(node); end
  def return_of_method_call?(node); end
  include RuboCop::Cop::RescueNode
end
class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  def accesses?(rhs, lhs); end
  def dependency?(lhs, rhs); end
  def initialize(assignments); end
  def matching_calls(node0, param1, param2); end
  def tsort_each_child(assignment); end
  def tsort_each_node; end
  def uses_var?(node0, param1); end
  def var_name(node = nil); end
  extend RuboCop::NodePattern::Macros
  include TSort
end
class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def assignment; end
  def config; end
  def cop_config; end
  def correction; end
  def correction_range; end
  def extract_sources(node); end
  def initialize(node, config, new_elements); end
  def node; end
  def source(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector < RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def begin_correction(rescue_result); end
  def correction; end
  def correction_range; end
  def def_correction(rescue_result); end
end
class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector < RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def correction; end
  def correction_range; end
  def modifier_range(node); end
end
class RuboCop::Cop::Style::ParenthesesAroundCondition < RuboCop::Cop::Cop
  def allow_multiline_conditions?; end
  def autocorrect(node); end
  def control_op_condition(node = nil); end
  def message(node); end
  def modifier_op?(node); end
  def on_if(node); end
  def on_until(node); end
  def on_while(node); end
  def parens_allowed?(node); end
  def process_control_op(node); end
  include RuboCop::Cop::Parentheses
  include RuboCop::Cop::SafeAssignment
end
class RuboCop::Cop::Style::PercentLiteralDelimiters < RuboCop::Cop::Cop
  def autocorrect(node); end
  def contains_preferred_delimiter?(node, type); end
  def include_same_character_as_used_for_delimiter?(node, type); end
  def matchpairs(begin_delimiter); end
  def message(node); end
  def on_array(node); end
  def on_dstr(node); end
  def on_percent_literal(node); end
  def on_regexp(node); end
  def on_str(node); end
  def on_sym(node); end
  def on_xstr(node); end
  def preferred_delimiters_for(type); end
  def string_source(node); end
  def uses_preferred_delimiter?(node, type); end
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Style::PercentQLiterals < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_literal_style?(node); end
  def corrected(src); end
  def message(_node); end
  def on_percent_literal(node); end
  def on_str(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Style::PerlBackrefs < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_nth_ref(node); end
end
class RuboCop::Cop::Style::PreferredHashMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def offending_selector?(method_name); end
  def on_csend(node); end
  def on_send(node); end
  def proper_method_name(method_name); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::Proc < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_block(node); end
  def proc_new?(node = nil); end
end
class RuboCop::Cop::Style::RaiseArgs < RuboCop::Cop::Cop
  def acceptable_exploded_args?(args); end
  def autocorrect(node); end
  def check_compact(node); end
  def check_exploded(node); end
  def correction_compact_to_exploded(node); end
  def correction_exploded_to_compact(node); end
  def message(node); end
  def on_send(node); end
  def requires_parens?(parent); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::RandomWithOffset < RuboCop::Cop::Cop
  def autocorrect(node); end
  def boundaries_from_random_node(random_node); end
  def corrected_integer_op_rand(node); end
  def corrected_rand_modified(node); end
  def corrected_rand_op_integer(node); end
  def integer_op_rand?(node = nil); end
  def namespace(node = nil); end
  def on_send(node); end
  def prefix_from_prefix_node(node); end
  def rand_modified?(node = nil); end
  def rand_op_integer?(node = nil); end
  def random_call(node = nil); end
  def to_int(node = nil); end
end
class RuboCop::Cop::Style::RedundantBegin < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end
end
class RuboCop::Cop::Style::RedundantConditional < RuboCop::Cop::Cop
  def autocorrect(node); end
  def configured_indentation_width; end
  def indented_else_node(expression, node); end
  def invert_expression?(node); end
  def message(node); end
  def offense?(node); end
  def on_if(node); end
  def redundant_condition?(node = nil); end
  def redundant_condition_inverted?(node = nil); end
  def replacement_condition(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Style::RedundantException < RuboCop::Cop::Cop
  def autocorrect(node); end
  def compact?(node = nil); end
  def exploded?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Style::RedundantFreeze < RuboCop::Cop::Cop
  def autocorrect(node); end
  def immutable_literal?(node); end
  def on_send(node); end
  def operation_produces_immutable_object?(node = nil); end
  def strip_parenthesis(node); end
  include RuboCop::Cop::FrozenStringLiteral
end
class RuboCop::Cop::Style::RedundantParentheses < RuboCop::Cop::Cop
  def allowed_ancestor?(node); end
  def allowed_array_or_hash_element?(node); end
  def allowed_expression?(node); end
  def allowed_method_call?(node); end
  def allowed_multiple_expression?(node); end
  def arg_in_call_with_block?(node = nil); end
  def array_element?(node); end
  def autocorrect(node); end
  def call_chain_starts_with_int?(begin_node, send_node); end
  def check(begin_node); end
  def check_send(begin_node, node); end
  def check_unary(begin_node, node); end
  def disallowed_literal?(begin_node, node); end
  def empty_parentheses?(node); end
  def first_argument?(node); end
  def first_send_argument?(node = nil); end
  def first_super_argument?(node = nil); end
  def hash_element?(node); end
  def hash_literal_as_first_arg?(node); end
  def keyword_ancestor?(node); end
  def keyword_with_redundant_parentheses?(node); end
  def method_call_with_redundant_parentheses?(node); end
  def method_node_and_args(node = nil); end
  def offense(node, msg); end
  def on_begin(node); end
  def only_begin_arg?(args); end
  def only_closing_paren_before_comma?(node); end
  def parens_allowed?(node); end
  def raised_to_power_negative_numeric?(begin_node, node); end
  def range_end?(node = nil); end
  def rescue?(node = nil); end
  def square_brackets?(node = nil); end
  def suspect_unary?(node); end
  include RuboCop::Cop::Parentheses
end
class RuboCop::Cop::Style::RedundantReturn < RuboCop::Cop::Cop
  def add_braces(corrector, node); end
  def add_brackets(corrector, node); end
  def allow_multiple_return_values?; end
  def arguments?(args); end
  def autocorrect(node); end
  def check_begin_node(node); end
  def check_branch(node); end
  def check_case_node(node); end
  def check_ensure_node(node); end
  def check_if_node(node); end
  def check_rescue_node(node); end
  def check_return_node(node); end
  def message(node); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::RedundantSelf < RuboCop::Cop::Cop
  def add_scope(node, local_variables = nil); end
  def allow_self(node); end
  def allowed_send_node?(node); end
  def autocorrect(node); end
  def initialize(config = nil, options = nil); end
  def keyword?(method_name); end
  def on_and_asgn(node); end
  def on_args(node); end
  def on_argument(node); end
  def on_block(node); end
  def on_blockarg(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_lvasgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
  def on_send(node); end
  def regular_method_call?(node); end
  def self.autocorrect_incompatible_with; end
end
class RuboCop::Cop::Style::RedundantSortBy < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_block(node); end
  def redundant_sort_by(node = nil); end
  def sort_by_range(send, node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::RegexpLiteral < RuboCop::Cop::Cop
  def allow_inner_slashes?; end
  def allowed_mixed_percent_r?(node); end
  def allowed_mixed_slash?(node); end
  def allowed_percent_r_literal?(node); end
  def allowed_slash_literal?(node); end
  def autocorrect(node); end
  def calculate_replacement(node); end
  def check_percent_r_literal(node); end
  def check_slash_literal(node); end
  def contains_disallowed_slash?(node); end
  def contains_slash?(node); end
  def correct_delimiters(node, corrector); end
  def correct_inner_slashes(node, corrector); end
  def inner_slash_after_correction(node); end
  def inner_slash_before_correction(node); end
  def inner_slash_for(opening_delimiter); end
  def inner_slash_indices(node); end
  def node_body(node, include_begin_nodes: nil); end
  def on_regexp(node); end
  def preferred_delimiters; end
  def slash_literal?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::RescueModifier < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_resbody(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::RescueNode
end
class RuboCop::Cop::Style::RescueStandardError < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_resbody(node); end
  def rescue_standard_error?(node = nil); end
  def rescue_without_error_class?(node = nil); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::RescueNode
end
class RuboCop::Cop::Style::ReturnNil < RuboCop::Cop::Cop
  def autocorrect(node); end
  def chained_send?(node = nil); end
  def correct_style?(node); end
  def define_method?(node = nil); end
  def message(_node); end
  def on_return(node); end
  def return_nil_node?(node = nil); end
  def return_node?(node = nil); end
  def scoped_node?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::SafeNavigation < RuboCop::Cop::Cop
  def add_safe_nav_to_all_methods_in_chain(corrector, start_method, method_chain); end
  def allowed_if_condition?(node); end
  def autocorrect(node); end
  def begin_range(node, method_call); end
  def chain_size(method_chain, method); end
  def check_node(node); end
  def end_range(node, method_call); end
  def extract_common_parts(method_chain, checked_variable); end
  def extract_parts(node); end
  def extract_parts_from_and(node); end
  def extract_parts_from_if(node); end
  def find_matching_receiver_invocation(method_chain, checked_variable); end
  def method_called?(send_node); end
  def modifier_if_safe_navigation_candidate(node = nil); end
  def negated?(send_node); end
  def not_nil_check?(node = nil); end
  def on_and(node); end
  def on_if(node); end
  def unsafe_method?(send_node); end
  def unsafe_method_used?(method_chain, method); end
  def use_var_only_in_unless_modifier?(node, variable); end
  include RuboCop::Cop::NilMethods
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::Sample < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correction(shuffle_arg, method, method_args); end
  def extract_source(args); end
  def message(shuffle_arg, method, method_args, range); end
  def offensive?(method, method_args); end
  def on_send(node); end
  def range_size(range_node); end
  def sample_arg(method, method_args); end
  def sample_candidate?(node = nil); end
  def sample_size(method_args); end
  def sample_size_for_one_arg(arg); end
  def sample_size_for_two_args(first, second); end
  def source_range(shuffle_node, node); end
end
class RuboCop::Cop::Style::SelfAssignment < RuboCop::Cop::Cop
  def apply_autocorrect(node, rhs, operator, new_rhs); end
  def autocorrect(node); end
  def autocorrect_boolean_node(node, rhs); end
  def autocorrect_send_node(node, rhs); end
  def check(node, var_type); end
  def check_boolean_node(node, rhs, var_name, var_type); end
  def check_send_node(node, rhs, var_name, var_type); end
  def on_cvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def self.autocorrect_incompatible_with; end
end
class RuboCop::Cop::Style::Semicolon < RuboCop::Cop::Cop
  def autocorrect(range); end
  def check_for_line_terminator_or_opener; end
  def convention_on(line, column, autocorrect); end
  def each_semicolon; end
  def investigate(processed_source); end
  def on_begin(node); end
  def tokens_for_lines; end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::Send < RuboCop::Cop::Cop
  def on_csend(node); end
  def on_send(node); end
  def sending?(node = nil); end
end
class RuboCop::Cop::Style::SignalException < RuboCop::Cop::Cop
  def allow(method_name, node); end
  def autocorrect(node); end
  def check_scope(method_name, node); end
  def check_send(method_name, node); end
  def command_or_kernel_call?(name, node); end
  def custom_fail_methods(node0); end
  def each_command_or_kernel_call(method_name, node); end
  def investigate(processed_source); end
  def kernel_call?(node = nil, param1); end
  def message(method_name); end
  def on_rescue(node); end
  def on_send(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::SingleLineBlockParams < RuboCop::Cop::Cop
  def args_match?(method_name, args); end
  def eligible_arguments?(node); end
  def eligible_method?(node); end
  def message(node); end
  def method_name(method); end
  def method_names; end
  def methods; end
  def on_block(node); end
  def target_args(method_name); end
end
class RuboCop::Cop::Style::SingleLineMethods < RuboCop::Cop::Cop
  def allow_empty?; end
  def autocorrect(node); end
  def each_part(body); end
  def move_comment(node, corrector); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Style::SpecialGlobalVars < RuboCop::Cop::Cop
  def autocorrect(node); end
  def english_name_replacement(preferred_name, node); end
  def format_english_message(global_var); end
  def format_list(items); end
  def format_message(english, regular, global); end
  def message(node); end
  def on_gvar(node); end
  def preferred_names(global); end
  def replacement(node, global_var); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::StabbyLambdaParentheses < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(_node); end
  def missing_parentheses?(node); end
  def missing_parentheses_corrector(node); end
  def on_send(node); end
  def parentheses?(node); end
  def redundant_parentheses?(node); end
  def stabby_lambda_with_args?(node); end
  def unwanted_parentheses_corrector(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Style::StderrPuts < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_send(node); end
  def stderr_gvar?(sym); end
  def stderr_puts?(node = nil); end
  def stderr_puts_range(send); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::StringHashKeys < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_pair(node); end
  def receive_environments_method?(node = nil); end
  def string_hash_key?(node = nil); end
end
class RuboCop::Cop::Style::StringLiterals < RuboCop::Cop::Cop
  def accept_child_double_quotes?(nodes); end
  def all_string_literals?(nodes); end
  def autocorrect(node); end
  def check_multiline_quote_style(node, quote); end
  def consistent_multiline?; end
  def detect_quote_styles(node); end
  def message(_node); end
  def offense?(node); end
  def on_dstr(node); end
  def unexpected_double_quotes?(quote); end
  def unexpected_single_quotes?(quote); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::StringLiteralsHelp
end
class RuboCop::Cop::Style::StringLiteralsInInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(_node); end
  def offense?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::StringLiteralsHelp
end
class RuboCop::Cop::Style::StringMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_csend(node); end
  def on_send(node); end
  include RuboCop::Cop::MethodPreference
end
class RuboCop::Cop::Style::Strip < RuboCop::Cop::Cop
  def autocorrect(node); end
  def lstrip_rstrip(node = nil); end
  def on_send(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::StructInheritance < RuboCop::Cop::Cop
  def on_class(node); end
  def struct_constructor?(node = nil); end
end
class RuboCop::Cop::Style::SymbolArray < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_bracketed(node); end
  def on_array(node); end
  def self.largest_brackets; end
  def self.largest_brackets=(arg0); end
  def symbol_without_quote?(string); end
  def symbols_contain_spaces?(node); end
  def to_symbol_literal(string); end
  include RuboCop::Cop::ArrayMinSize
  include RuboCop::Cop::ArraySyntax
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::PercentArray
end
class RuboCop::Cop::Style::SymbolLiteral < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_sym(node); end
end
class RuboCop::Cop::Style::SymbolProc < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_with_args(corrector, node, args, method_name); end
  def autocorrect_without_args(corrector, node); end
  def begin_pos_for_replacement(node); end
  def block_range_with_space(node); end
  def destructuring_block_argument?(argument_node); end
  def on_block(node); end
  def proc_node?(node = nil); end
  def register_offense(node, method_name, block_method_name); end
  def self.autocorrect_incompatible_with; end
  def symbol_proc?(node = nil); end
  include RuboCop::Cop::IgnoredMethods
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::TernaryParentheses < RuboCop::Cop::Cop
  def autocorrect(node); end
  def complex_condition?(condition); end
  def correct_parenthesized(condition); end
  def correct_unparenthesized(condition); end
  def infinite_loop?; end
  def message(node); end
  def method_name(node = nil); end
  def non_complex_expression?(condition); end
  def non_complex_send?(node); end
  def offense?(node); end
  def on_if(node); end
  def parenthesized?(node); end
  def redundant_parentheses_enabled?; end
  def require_parentheses?; end
  def require_parentheses_when_complex?; end
  def unparenthesized_method_call?(child); end
  def unsafe_autocorrect?(condition); end
  def whitespace_after?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::SafeAssignment
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Style::TrailingBodyOnClass < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_class(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::TrailingBody
end
class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_def(node); end
  def on_defs(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::TrailingBody
end
class RuboCop::Cop::Style::TrailingBodyOnModule < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_module(node); end
  include RuboCop::Cop::Alignment
  include RuboCop::Cop::TrailingBody
end
class RuboCop::Cop::Style::TrailingCommaInArguments < RuboCop::Cop::Cop
  def autocorrect(range); end
  def avoid_autocorrect?(args); end
  def braces_will_be_removed?(args); end
  def on_csend(node); end
  def on_send(node); end
  def self.autocorrect_incompatible_with; end
  include RuboCop::Cop::TrailingComma
end
class RuboCop::Cop::Style::TrailingCommaInArrayLiteral < RuboCop::Cop::Cop
  def autocorrect(range); end
  def on_array(node); end
  include RuboCop::Cop::TrailingComma
end
class RuboCop::Cop::Style::TrailingCommaInHashLiteral < RuboCop::Cop::Cop
  def autocorrect(range); end
  def on_hash(node); end
  include RuboCop::Cop::TrailingComma
end
class RuboCop::Cop::Style::TrailingMethodEndStatement < RuboCop::Cop::Cop
  def autocorrect(node); end
  def body_and_end_on_same_line?(node); end
  def break_line_before_end(node, corrector); end
  def end_token(node); end
  def on_def(node); end
  def remove_semicolon(node, corrector); end
  def token_before_end(node); end
  def trailing_end?(node); end
  include RuboCop::Cop::Alignment
end
class RuboCop::Cop::Style::TrailingUnderscoreVariable < RuboCop::Cop::Cop
  def allow_named_underscore_variables; end
  def autocorrect(node); end
  def children_offenses(variables); end
  def find_first_offense(variables); end
  def find_first_possible_offense(variables); end
  def main_node_offense(node); end
  def on_masgn(node); end
  def range_for_parentheses(offense, left); end
  def reverse_index(collection, item); end
  def splat_variable_before?(first_offense, variables); end
  def unneeded_ranges(node); end
  def unused_range(node_type, mlhs_node, right); end
  def unused_variables_only?(offense, variables); end
  include RuboCop::Cop::RangeHelp
  include RuboCop::Cop::SurroundingSpace
end
class RuboCop::Cop::Style::TrivialAccessors < RuboCop::Cop::Cop
  def accessor(kind, method_name); end
  def allow_dsl_writers?; end
  def allow_predicates?; end
  def allowed_method?(node); end
  def allowed_reader?(node); end
  def allowed_writer?(method_name); end
  def autocorrect(node); end
  def autocorrect_class(node); end
  def autocorrect_instance(node); end
  def dsl_writer?(method_name); end
  def exact_name_match?; end
  def ignore_class_methods?; end
  def in_module_or_instance_eval?(node); end
  def looks_like_trivial_reader?(node); end
  def looks_like_trivial_writer?(node = nil); end
  def names_match?(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_method_def(node); end
  def top_level_node?(node); end
  def trivial_accessor_kind(node); end
  def trivial_reader?(node); end
  def trivial_writer?(node); end
  def whitelist; end
end
class RuboCop::Cop::Style::UnlessElse < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_if(node); end
  def range_between_condition_and_else(node, condition); end
  def range_between_else_and_end(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::UnneededCapitalW < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_array(node); end
  def on_percent_literal(node); end
  def requires_interpolation?(node); end
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Style::UnneededCondition < RuboCop::Cop::Cop
  def autocorrect(node); end
  def else_source(else_branch); end
  def make_ternary_form(node); end
  def message(node); end
  def offense?(node); end
  def on_if(node); end
  def range_of_offense(node); end
  def use_if_branch?(else_branch); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::UnneededInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_other(embedded_node, node); end
  def autocorrect_single_variable_interpolation(embedded_node, node); end
  def autocorrect_variable_interpolation(embedded_node, node); end
  def embedded_in_percent_array?(node); end
  def implicit_concatenation?(node); end
  def interpolation?(node); end
  def on_dstr(node); end
  def self.autocorrect_incompatible_with; end
  def single_interpolation?(node); end
  def single_variable_interpolation?(node); end
  def variable_interpolation?(node); end
  include RuboCop::Cop::PercentLiteral
end
class RuboCop::Cop::Style::UnneededPercentQ < RuboCop::Cop::Cop
  def acceptable_capital_q?(node); end
  def acceptable_q?(node); end
  def allowed_percent_q?(node); end
  def autocorrect(node); end
  def check(node); end
  def interpolated_quotes?(node); end
  def message(node); end
  def on_dstr(node); end
  def on_str(node); end
  def start_with_percent_q_variant?(string); end
  def string_literal?(node); end
end
class RuboCop::Cop::Style::UnneededSort < RuboCop::Cop::Cop
  def accessor_start(node); end
  def arg_node(node); end
  def arg_value(node); end
  def autocorrect(node); end
  def base(accessor, arg); end
  def message(node, sorter, accessor); end
  def on_send(node); end
  def suffix(sorter); end
  def suggestion(sorter, accessor, arg); end
  def unneeded_sort?(node = nil); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::UnpackFirst < RuboCop::Cop::Cop
  def autocorrect(node); end
  def first_element_range(node, unpack_call); end
  def on_send(node); end
  def unpack_and_first_element?(node = nil); end
  extend RuboCop::Cop::TargetRubyVersion
end
class RuboCop::Cop::Style::VariableInterpolation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_for_interpolation(node); end
  def message(node); end
  def on_dstr(node); end
  def on_regexp(node); end
  def on_xstr(node); end
  def var_nodes(nodes); end
end
class RuboCop::Cop::Style::WhenThen < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_when(node); end
end
class RuboCop::Cop::Style::WhileUntilDo < RuboCop::Cop::Cop
  def autocorrect(node); end
  def handle(node); end
  def on_until(node); end
  def on_while(node); end
end
class RuboCop::Cop::Style::WhileUntilModifier < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check(node); end
  def on_until(node); end
  def on_while(node); end
  include RuboCop::Cop::StatementModifier
end
class RuboCop::Cop::Style::WordArray < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_bracketed_array(node); end
  def complex_content?(strings); end
  def correct_bracketed(node); end
  def on_array(node); end
  def self.largest_brackets; end
  def self.largest_brackets=(arg0); end
  def word_regex; end
  include RuboCop::Cop::ArrayMinSize
  include RuboCop::Cop::ArraySyntax
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::PercentArray
end
class RuboCop::Cop::Style::YodaCondition < RuboCop::Cop::Cop
  def actual_code_range(node); end
  def autocorrect(node); end
  def corrected_code(node); end
  def enforce_yoda?; end
  def equality_only?; end
  def message(node); end
  def non_equality_operator?(node); end
  def noncommutative_operator?(node); end
  def on_send(node); end
  def reverse_comparison(operator); end
  def valid_yoda?(node); end
  def yoda_compatible_condition?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Style::ZeroLengthPredicate < RuboCop::Cop::Cop
  def autocorrect(node); end
  def check_nonzero_length_predicate(node); end
  def check_zero_length_predicate(node); end
  def non_polymorphic_collection?(node = nil); end
  def nonzero_length_predicate(node = nil); end
  def on_send(node); end
  def other_receiver(node = nil); end
  def replacement(node); end
  def zero_length_predicate(node = nil); end
  def zero_length_receiver(node = nil); end
end
module RuboCop::Cop::Rails
end
class RuboCop::Cop::Rails::ActionFilter < RuboCop::Cop::Cop
  def autocorrect(node); end
  def bad_methods; end
  def check_method_node(node); end
  def good_methods; end
  def message(node); end
  def on_block(node); end
  def on_send(node); end
  def preferred_method(method); end
  extend RuboCop::Cop::TargetRailsVersion
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Rails::ActiveRecordAliases < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_csend(node); end
  def on_send(node); end
end
class RuboCop::Cop::Rails::ActiveRecordOverride < RuboCop::Cop::Cop
  def active_model?(parent_class_name); end
  def callback_names(method_name); end
  def find_parent_class_name(node); end
  def message(method_name); end
  def on_def(node); end
end
class RuboCop::Cop::Rails::ActiveSupportAliases < RuboCop::Cop::Cop
  def append(node = nil); end
  def autocorrect(node); end
  def ends_with?(node = nil); end
  def on_send(node); end
  def prepend(node = nil); end
  def register_offense(node, method_name); end
  def starts_with?(node = nil); end
end
class RuboCop::Cop::Rails::ApplicationJob < RuboCop::Cop::Cop
  def autocorrect(node); end
  def class_definition(node = nil); end
  def class_new_definition(node = nil); end
  extend RuboCop::Cop::TargetRailsVersion
  include RuboCop::Cop::EnforceSuperclass
end
class RuboCop::Cop::Rails::ApplicationRecord < RuboCop::Cop::Cop
  def autocorrect(node); end
  def class_definition(node = nil); end
  def class_new_definition(node = nil); end
  extend RuboCop::Cop::TargetRailsVersion
  include RuboCop::Cop::EnforceSuperclass
end
class RuboCop::Cop::Rails::AssertNot < RuboCop::Cop::Cop
  def autocorrect(node); end
  def corrected_source(source); end
  def offensive?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Rails::BelongsTo < RuboCop::Cop::Cop
  def autocorrect(node); end
  def match_belongs_to_with_options(node = nil); end
  def on_send(node); end
  extend RuboCop::Cop::TargetRailsVersion
end
class RuboCop::Cop::Rails::Blank < RuboCop::Cop::Cop
  def autocorrect(node); end
  def defining_blank?(node = nil); end
  def nil_or_empty?(node = nil); end
  def not_present?(node = nil); end
  def on_if(node); end
  def on_or(node); end
  def on_send(node); end
  def replacement(node); end
  def unless_condition(node, method_call); end
  def unless_present?(node = nil); end
end
class RuboCop::Cop::Rails::BulkChangeTable < RuboCop::Cop::Cop
  def add_offense_for_alter_methods(node); end
  def add_offense_for_change_table(node); end
  def combinable_alter_methods; end
  def combinable_transformations; end
  def database; end
  def database_from_yaml; end
  def database_yaml; end
  def include_bulk_options?(node); end
  def on_def(node); end
  def on_send(node); end
  def support_bulk_alter?; end
end
class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  def flush; end
  def initialize; end
  def offensive_nodes; end
  def process(new_node); end
end
class RuboCop::Cop::Rails::CreateTableWithTimestamps < RuboCop::Cop::Cop
  def create_table_with_block?(node = nil); end
  def create_table_with_timestamps_proc?(node = nil); end
  def created_at_or_updated_at_included?(node0); end
  def on_send(node); end
  def time_columns_included?(node); end
  def timestamps_included?(node0); end
end
class RuboCop::Cop::Rails::Date < RuboCop::Cop::Cop
  def bad_days; end
  def bad_methods; end
  def check_date_node(node); end
  def check_deprecated_methods(node); end
  def extract_method_chain(node); end
  def good_days; end
  def good_methods; end
  def method_send?(node); end
  def on_const(node); end
  def on_csend(node); end
  def on_send(node); end
  def safe_chain?(node); end
  def safe_to_time?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Rails::Delegate < RuboCop::Cop::Cop
  def arguments_match?(arg_array, body); end
  def autocorrect(node); end
  def delegate?(node = nil); end
  def include_prefix_case?; end
  def method_name_matches?(method_name, body); end
  def on_def(node); end
  def prefixed_method_name(body); end
  def private_or_protected_before(line); end
  def private_or_protected_delegation(node); end
  def private_or_protected_inline(line); end
  def trivial_delegate?(def_node); end
end
class RuboCop::Cop::Rails::DelegateAllowBlank < RuboCop::Cop::Cop
  def allow_blank_option(node = nil); end
  def autocorrect(pair_node); end
  def on_send(node); end
end
class RuboCop::Cop::Rails::DynamicFindBy < RuboCop::Cop::Cop
  def autocorrect(node); end
  def autocorrect_argument_keywords(corrector, node, keywords); end
  def autocorrect_method_name(corrector, node); end
  def column_keywords(method); end
  def on_csend(node); end
  def on_send(node); end
  def static_method_name(method_name); end
  def whitelist; end
end
class RuboCop::Cop::Rails::EnumUniqueness < RuboCop::Cop::Cop
  def enum_declaration(node = nil); end
  def on_send(node); end
  include RuboCop::Cop::Duplication
end
class RuboCop::Cop::Rails::EnvironmentComparison < RuboCop::Cop::Cop
  def autocorrect(node); end
  def content(node = nil); end
  def environment_str_comparison?(node = nil); end
  def environment_sym_comparison?(node = nil); end
  def on_send(node); end
  def replacement(node); end
end
class RuboCop::Cop::Rails::Exit < RuboCop::Cop::Cop
  def offending_node?(node); end
  def on_send(node); end
  def right_argument_count?(arg_nodes); end
  def right_method_name?(method_name); end
  def right_receiver?(receiver_node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Rails::FilePath < RuboCop::Cop::Cop
  def check_for_file_join_with_rails_root(node); end
  def check_for_rails_root_join_with_slash_separated_path(node); end
  def check_for_rails_root_join_with_string_arguments(node); end
  def file_join_nodes?(node = nil); end
  def message(_node); end
  def on_dstr(node); end
  def on_send(node); end
  def rails_root_join_nodes?(node = nil); end
  def rails_root_nodes?(node0); end
  def register_offense(node); end
  def string_with_slash?(node); end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::FindBy < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_csend(node); end
  def on_send(node); end
  def where_first?(node = nil); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::FindEach < RuboCop::Cop::Cop
  def autocorrect(node); end
  def ignored_by_find_each?(relation_method); end
  def method_chain(node); end
  def on_send(node); end
end
class RuboCop::Cop::Rails::HasAndBelongsToMany < RuboCop::Cop::Cop
  def on_send(node); end
end
class RuboCop::Cop::Rails::HasManyOrHasOneDependent < RuboCop::Cop::Cop
  def active_resource?(node); end
  def active_resource_class?(node0); end
  def association_with_options?(node = nil); end
  def association_without_options?(node = nil); end
  def contain_valid_options_in_with_options_block?(node); end
  def dependent_option?(node = nil); end
  def on_send(node); end
  def present_option?(node = nil); end
  def valid_options?(options); end
  def valid_options_in_with_options_block?(node); end
  def with_options_block(node = nil); end
end
class RuboCop::Cop::Rails::HttpPositionalArguments < RuboCop::Cop::Cop
  def autocorrect(node); end
  def convert_hash_data(data, type); end
  def correction(node); end
  def correction_template(node); end
  def format_arg?(node); end
  def http_request?(node = nil); end
  def needs_conversion?(data); end
  def on_send(node); end
  def special_keyword_arg?(node); end
  extend RuboCop::Cop::TargetRailsVersion
end
class RuboCop::Cop::Rails::HttpStatus < RuboCop::Cop::Cop
  def autocorrect(node); end
  def checker_class; end
  def http_status(node = nil); end
  def on_send(node); end
  def status_code(node = nil); end
  def support_autocorrect?; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  def custom_http_status_code?; end
  def initialize(node); end
  def message; end
  def node; end
  def number; end
  def offensive?; end
  def preferred_style; end
  def symbol; end
end
class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  def initialize(node); end
  def message; end
  def node; end
  def number; end
  def offensive?; end
  def permitted_symbol?; end
  def preferred_style; end
  def symbol; end
end
class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption < RuboCop::Cop::Cop
  def filter_options(node = nil); end
  def if_and_except?(options); end
  def if_and_only?(options); end
  def on_send(node); end
  def options_hash(options); end
end
class RuboCop::Cop::Rails::InverseOf < RuboCop::Cop::Cop
  def as_option?(node = nil); end
  def association_recv_arguments(node = nil); end
  def conditions_option?(node = nil); end
  def foreign_key_option?(node = nil); end
  def inverse_of_nil_option?(node = nil); end
  def inverse_of_option?(node = nil); end
  def message(options); end
  def on_send(node); end
  def options_contain_inverse_of?(options); end
  def options_from_argument(node = nil); end
  def options_ignoring_inverse_of?(options); end
  def options_requiring_inverse_of?(options); end
  def polymorphic_option?(node = nil); end
  def same_context_in_with_options?(arg, recv); end
  def scope?(arguments); end
  def through_option?(node = nil); end
  def with_options_arguments(recv, node); end
  extend RuboCop::Cop::TargetRailsVersion
end
class RuboCop::Cop::Rails::LexicallyScopedActionFilter < RuboCop::Cop::Cop
  def array_values(node); end
  def message(methods, parent); end
  def on_send(node); end
  def only_or_except_filter_methods(node = nil); end
end
class RuboCop::Cop::Rails::LinkToBlank < RuboCop::Cop::Cop
  def add_rel(send_node, offence_node, corrector); end
  def append_to_rel(rel_node, corrector); end
  def autocorrect(node); end
  def blank_target?(node = nil); end
  def contains_noopener?(value); end
  def includes_noopener?(node = nil); end
  def on_send(node); end
  def rel_node?(node = nil); end
end
class RuboCop::Cop::Rails::NotNullColumn < RuboCop::Cop::Cop
  def add_not_null_column?(node = nil); end
  def add_not_null_reference?(node = nil); end
  def check_add_column(node); end
  def check_add_reference(node); end
  def check_pairs(pairs); end
  def default_option?(node = nil); end
  def null_false?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Rails::Output < RuboCop::Cop::Cop
  def io_output?(node = nil); end
  def match_gvar?(sym); end
  def on_send(node); end
  def output?(node = nil); end
end
class RuboCop::Cop::Rails::OutputSafety < RuboCop::Cop::Cop
  def looks_like_rails_html_safe?(node); end
  def looks_like_rails_raw?(node); end
  def looks_like_rails_safe_concat?(node); end
  def non_interpolated_string?(node); end
  def on_csend(node); end
  def on_send(node); end
end
class RuboCop::Cop::Rails::PluralizationGrammar < RuboCop::Cop::Cop
  def autocorrect(node); end
  def correct_method(method_name); end
  def duration_method?(method_name); end
  def literal_number?(node); end
  def message(node); end
  def offense?(node); end
  def on_send(node); end
  def plural_method?(method_name); end
  def plural_receiver?(number); end
  def pluralize(method_name); end
  def singular_method?(method_name); end
  def singular_receiver?(number); end
  def singularize(method_name); end
end
class RuboCop::Cop::Rails::Presence < RuboCop::Cop::Cop
  def autocorrect(node); end
  def ignore_if_node?(node); end
  def ignore_other_node?(node); end
  def message(node, receiver, other); end
  def on_if(node); end
  def redundant_negative_receiver_and_other(node = nil); end
  def redundant_receiver_and_other(node = nil); end
  def replacement(receiver, other); end
end
class RuboCop::Cop::Rails::Present < RuboCop::Cop::Cop
  def autocorrect(node); end
  def exists_and_not_empty?(node = nil); end
  def not_blank?(node = nil); end
  def on_and(node); end
  def on_if(node); end
  def on_or(node); end
  def on_send(node); end
  def replacement(node); end
  def unless_blank?(node = nil); end
  def unless_condition(node, method_call); end
end
class RuboCop::Cop::Rails::ReadWriteAttribute < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(node); end
  def on_send(node); end
  def read_attribute_replacement(node); end
  def read_write_attribute?(node = nil); end
  def write_attribute_replacement(node); end
end
class RuboCop::Cop::Rails::RedundantAllowNil < RuboCop::Cop::Cop
  def autocorrect(node); end
  def find_allow_nil_and_allow_blank(node); end
  def next_sibling(node); end
  def node_beg(node); end
  def node_end(node); end
  def offense(allow_nil_val, allow_blank_val, allow_nil); end
  def on_send(node); end
  def previous_sibling(node); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::RedundantReceiverInWithOptions < RuboCop::Cop::Cop
  def all_block_nodes_in(node0); end
  def all_send_nodes_in(node0); end
  def autocorrect(node); end
  def block_argument_range(node); end
  def on_block(node); end
  def same_value?(arg_node, recv_node); end
  def search_begin_pos_of_space_before_block_argument(begin_pos); end
  def with_options?(node = nil); end
  extend RuboCop::Cop::TargetRailsVersion
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::ReflectionClassName < RuboCop::Cop::Cop
  def association_with_reflection(node = nil); end
  def on_send(node); end
  def reflection_class_name(node = nil); end
end
class RuboCop::Cop::Rails::RefuteMethods < RuboCop::Cop::Cop
  def autocorrect(node); end
  def offense_message(method_name); end
  def offensive?(node = nil); end
  def on_send(node); end
  def refute_method?(method_name); end
end
class RuboCop::Cop::Rails::RelativeDateConstant < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_casgn(node); end
  def on_masgn(node); end
  def on_or_asgn(node); end
  def relative_date?(node = nil); end
  def relative_date_assignment?(node = nil); end
  def relative_date_or_assignment?(node = nil); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::RequestReferer < RuboCop::Cop::Cop
  def autocorrect(node); end
  def message(_node); end
  def on_send(node); end
  def referer?(node = nil); end
  def wrong_method_name; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Rails::ReversibleMigration < RuboCop::Cop::Cop
  def all_hash_key?(args, *keys); end
  def change_column_default_call(node = nil); end
  def change_table_call(node = nil); end
  def check_change_column_default_node(node); end
  def check_change_table_node(node, block); end
  def check_change_table_offense(receiver, node); end
  def check_drop_table_node(node); end
  def check_irreversible_schema_statement_node(node); end
  def check_remove_column_node(node); end
  def check_remove_foreign_key_node(node); end
  def drop_table_call(node = nil); end
  def irreversible_schema_statement_call(node = nil); end
  def on_block(node); end
  def on_send(node); end
  def remove_column_call(node = nil); end
  def remove_foreign_key_call(node = nil); end
  def within_change_method?(node); end
  def within_reversible_or_up_only_block?(node); end
end
class RuboCop::Cop::Rails::SafeNavigation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  def replacement(method, params); end
  def try_call(node = nil); end
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::SaveBang < RuboCop::Cop::Cop
  def add_offense_for_node(node, msg = nil); end
  def after_leaving_scope(scope, _variable_table); end
  def allowed_receiver?(node); end
  def argument?(node); end
  def array_parent(node); end
  def assignable_node(node); end
  def autocorrect(node); end
  def call_to_persisted?(node); end
  def check_assignment(assignment); end
  def check_used_in_conditional(node); end
  def conditional?(node); end
  def const_matches?(const, allowed_const); end
  def expected_signature?(node); end
  def explicit_return?(node); end
  def hash_parent(node); end
  def implicit_return?(node); end
  def join_force?(force_class); end
  def on_csend(node); end
  def on_send(node); end
  def persist_method?(node, methods = nil); end
  def persisted_referenced?(assignment); end
  def receiver_chain_matches?(node, allowed_receiver); end
  def return_value_assigned?(node); end
  def right_assignment_node(assignment); end
  include RuboCop::Cop::NegativeConditional
end
class RuboCop::Cop::Rails::ScopeArgs < RuboCop::Cop::Cop
  def on_send(node); end
  def scope?(node = nil); end
end
class RuboCop::Cop::Rails::SkipsModelValidations < RuboCop::Cop::Cop
  def allowed_method?(node); end
  def blacklist; end
  def good_touch?(node = nil); end
  def message(node); end
  def on_csend(node); end
  def on_send(node); end
  def whitelist; end
end
class RuboCop::Cop::Rails::TimeZone < RuboCop::Cop::Cop
  def acceptable_methods(klass, method_name, node); end
  def autocorrect(node); end
  def build_message(klass, method_name, node); end
  def check_localtime(node); end
  def check_time_node(klass, node); end
  def extract_method_chain(node); end
  def flexible?; end
  def good_methods; end
  def method_from_time_class?(node); end
  def method_send?(node); end
  def need_check_localtime?(chain); end
  def not_danger_chain?(chain); end
  def offset_provided?(node); end
  def on_const(node); end
  def remove_redundant_in_time_zone(corrector, node); end
  def safe_method(method_name, node); end
  def strict?; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
end
class RuboCop::Cop::Rails::UniqBeforePluck < RuboCop::Cop::Cop
  def aggressive_node_match(node = nil); end
  def autocorrect(node); end
  def conservative_node_match(node = nil); end
  def dot_method_begin_pos(method, node); end
  def dot_method_with_whitespace(method, node); end
  def on_send(node); end
  def style_parameter_name; end
  include RuboCop::Cop::ConfigurableEnforcedStyle
  include RuboCop::Cop::RangeHelp
end
class RuboCop::Cop::Rails::UnknownEnv < RuboCop::Cop::Cop
  def collect_variable_like_names(_scope); end
  def environments; end
  def message(name); end
  def on_send(node); end
  def unknown_env_name?(name); end
  def unknown_environment?(node = nil); end
  include RuboCop::NameSimilarity
end
class RuboCop::Cop::Rails::Validation < RuboCop::Cop::Cop
  def autocorrect(node); end
  def braced_options(options); end
  def correct_validate_type(corrector, node); end
  def message(node); end
  def on_send(node); end
  def preferred_method(method); end
end
module RuboCop::Cop::Security
end
class RuboCop::Cop::Security::Eval < RuboCop::Cop::Cop
  def eval?(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Security::JSONLoad < RuboCop::Cop::Cop
  def autocorrect(node); end
  def json_load(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Security::MarshalLoad < RuboCop::Cop::Cop
  def marshal_load(node = nil); end
  def on_send(node); end
end
class RuboCop::Cop::Security::Open < RuboCop::Cop::Cop
  def composite_string?(node); end
  def concatenated_string?(node); end
  def interpolated_string?(node); end
  def on_send(node); end
  def open?(node = nil); end
  def safe?(node); end
  def safe_argument?(argument); end
  def simple_string?(node); end
end
class RuboCop::Cop::Security::YAMLLoad < RuboCop::Cop::Cop
  def autocorrect(node); end
  def on_send(node); end
  def yaml_load(node = nil); end
end
class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end
  def autocorrect?; end
  def autocorrect_all_cops(buffer, cops); end
  def collate_corrections(corrector, cops); end
  def cops; end
  def debug?; end
  def errors; end
  def forces; end
  def forces_for(cops); end
  def handle_error(error, location, cop); end
  def handle_warning(error, location); end
  def initialize(cop_classes, config, options = nil); end
  def inspect_file(processed_source); end
  def investigate(cops, processed_source); end
  def offenses(processed_source); end
  def process_commissioner_errors(file, file_errors); end
  def updated_source_file; end
  def updated_source_file?; end
  def validate_config; end
  def warnings; end
end
class RuboCop::Cop::Team::Investigation < Struct
  def errors; end
  def errors=(_); end
  def offenses; end
  def offenses=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module RuboCop::Formatter
end
class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
  def file_started(file, options); end
  def finished(inspected_files); end
  def initialize(output, options = nil); end
  def options; end
  def output; end
  def started(target_files); end
end
module RuboCop::Formatter::Colorizable
  def black(string); end
  def blue(string); end
  def colorize(string, *args); end
  def cyan(string); end
  def green(string); end
  def magenta(string); end
  def rainbow; end
  def red(string); end
  def white(string); end
  def yellow(string); end
end
module RuboCop::Formatter::TextUtil
  def pluralize(number, thing, options = nil); end
  def self.pluralize(number, thing, options = nil); end
end
class RuboCop::Formatter::SimpleTextFormatter < RuboCop::Formatter::BaseFormatter
  def annotate_message(msg); end
  def colored_severity_code(offense); end
  def count_stats(offenses); end
  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def message(offense); end
  def report_file(file, offenses); end
  def report_summary(file_count, offense_count, correction_count); end
  def started(_target_files); end
  include RuboCop::Formatter::Colorizable
  include RuboCop::PathUtil
end
class RuboCop::Formatter::SimpleTextFormatter::Report
  def corrections; end
  def files; end
  def initialize(file_count, offense_count, correction_count, rainbow); end
  def offenses; end
  def rainbow; end
  def summary; end
  include RuboCop::Formatter::Colorizable
  include RuboCop::Formatter::TextUtil
end
class RuboCop::Formatter::ClangStyleFormatter < RuboCop::Formatter::SimpleTextFormatter
  def report_file(file, offenses); end
  def report_highlighted_area(highlighted_area); end
  def report_line(location); end
  def report_offense(file, offense); end
  def valid_line?(offense); end
end
class RuboCop::Formatter::DisabledConfigFormatter < RuboCop::Formatter::BaseFormatter
  def command; end
  def cop_config_params(default_cfg, cfg); end
  def default_config(cop_name); end
  def excludes(offending_files, cop_name, parent); end
  def file_finished(file, offenses); end
  def file_started(_file, _file_info); end
  def finished(_inspected_files); end
  def initialize(output, options = nil); end
  def output_cop(cop_name, offense_count); end
  def output_cop_comments(output_buffer, cfg, cop_name, offense_count); end
  def output_cop_config(output_buffer, cfg, cop_name); end
  def output_cop_param_comments(output_buffer, params, default_cfg); end
  def output_exclude_list(output_buffer, offending_files, cop_name); end
  def output_exclude_path(output_buffer, exclude_path, parent); end
  def output_offending_files(output_buffer, cfg, cop_name); end
  def output_offenses; end
  def self.config_to_allow_offenses; end
  def self.config_to_allow_offenses=(arg0); end
  def self.detected_styles; end
  def self.detected_styles=(arg0); end
  def set_max(cfg, cop_name); end
  def timestamp; end
end
class RuboCop::Formatter::DisabledLinesFormatter < RuboCop::Formatter::BaseFormatter
  def cop_disabled_line_ranges; end
  def cops_disabled_in_comments_summary; end
  def file_started(file, options); end
  def finished(_inspected_files); end
  def smart_path(path); end
  def started(_target_files); end
  include RuboCop::Formatter::Colorizable
  include RuboCop::PathUtil
end
class RuboCop::Formatter::EmacsStyleFormatter < RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
end
class RuboCop::Formatter::FileListFormatter < RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
end
class RuboCop::Formatter::FuubarStyleFormatter < RuboCop::Formatter::ClangStyleFormatter
  def count_stats(offenses); end
  def file_finished(file, offenses); end
  def initialize(*output); end
  def progressbar_color; end
  def started(target_files); end
  def with_color; end
end
class RuboCop::Formatter::HTMLFormatter < RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
  def files; end
  def finished(inspected_files); end
  def initialize(output, options = nil); end
  def render_html; end
  def started(target_files); end
  def summary; end
end
class RuboCop::Formatter::HTMLFormatter::Color < Struct
  def alpha; end
  def alpha=(_); end
  def blue; end
  def blue=(_); end
  def fade_out(amount); end
  def green; end
  def green=(_); end
  def red; end
  def red=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
end
class RuboCop::Formatter::HTMLFormatter::ERBContext
  def base64_encoded_logo_image; end
  def binding; end
  def decorated_message(offense); end
  def escape(string); end
  def files; end
  def highlighted_source_line(offense); end
  def hightlight_source_tag(offense); end
  def initialize(files, summary); end
  def possible_ellipses(location); end
  def source_after_highlight(offense); end
  def source_before_highlight(offense); end
  def summary; end
  include RuboCop::Formatter::TextUtil
  include RuboCop::PathUtil
end
class RuboCop::Formatter::JSONFormatter < RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def hash_for_file(file, offenses); end
  def hash_for_location(offense); end
  def hash_for_offense(offense); end
  def initialize(output, options = nil); end
  def metadata_hash; end
  def output_hash; end
  def started(target_files); end
  include RuboCop::PathUtil
end
class RuboCop::Formatter::OffenseCountFormatter < RuboCop::Formatter::BaseFormatter
  def file_finished(_file, offenses); end
  def finished(_inspected_files); end
  def offense_counts; end
  def ordered_offense_counts(offense_counts); end
  def report_summary(offense_counts); end
  def started(target_files); end
  def total_offense_count(offense_counts); end
end
class RuboCop::Formatter::ProgressFormatter < RuboCop::Formatter::ClangStyleFormatter
  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def initialize(output, options = nil); end
  def report_file_as_mark(offenses); end
  def started(target_files); end
  include RuboCop::Formatter::TextUtil
end
class RuboCop::Formatter::QuietFormatter < RuboCop::Formatter::SimpleTextFormatter
  def report_summary(file_count, offense_count, correction_count); end
end
class RuboCop::Formatter::TapFormatter < RuboCop::Formatter::ClangStyleFormatter
  def annotate_message(msg); end
  def file_finished(file, offenses); end
  def message(offense); end
  def report_highlighted_area(highlighted_area); end
  def report_line(location); end
  def report_offense(file, offense); end
  def started(target_files); end
end
class RuboCop::Formatter::WorstOffendersFormatter < RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
  def finished(_inspected_files); end
  def offense_counts; end
  def ordered_offense_counts(offense_counts); end
  def report_summary(offense_counts); end
  def started(target_files); end
  def total_offense_count(offense_counts); end
end
class RuboCop::Formatter::AutoGenConfigFormatter < RuboCop::Formatter::ProgressFormatter
  def finished(inspected_files); end
end
class RuboCop::Formatter::FormatterSet < Array
  def add_formatter(formatter_type, output_path = nil); end
  def builtin_formatter_class(specified_key); end
  def close_output_files; end
  def custom_formatter_class(specified_class_name); end
  def file_finished(file, offenses); end
  def file_started(file, options); end
  def finished(*args); end
  def formatter_class(formatter_type); end
  def initialize(options = nil); end
  def started(*args); end
end
class RuboCop::CachedData
  def deserialize_offenses(offenses); end
  def from_json(text); end
  def initialize(filename); end
  def message(offense); end
  def serialize_offense(offense); end
  def to_json(offenses); end
end
class RuboCop::Config
  def [](key); end
  def []=(key, value); end
  def add_excludes_from_higher_level(highest_config); end
  def allowed_camel_case_file?(file); end
  def base_dir_for_path_parameters; end
  def bundler_lock_file_path; end
  def check; end
  def check_target_ruby; end
  def delete(key); end
  def deprecation_check; end
  def each(&block); end
  def each_key(&block); end
  def enable_cop?(qualified_cop_name, cop_options); end
  def file_to_exclude?(file); end
  def file_to_include?(file); end
  def for_all_cops; end
  def for_cop(cop); end
  def initialize(hash = nil, loaded_path = nil); end
  def key?(key); end
  def keys; end
  def loaded_path; end
  def make_excludes_absolute; end
  def map(&block); end
  def merge(other_hash); end
  def obsolete_cops; end
  def obsolete_parameter_message(cop, parameter, alternative); end
  def obsolete_parameters; end
  def path_relative_to_config(path); end
  def patterns_to_exclude; end
  def patterns_to_include; end
  def possibly_include_hidden?; end
  def read_rails_version_from_bundler_lock_file; end
  def read_ruby_version_from_bundler_lock_file; end
  def reject_mutually_exclusive_defaults; end
  def reject_obsolete_cops_and_parameters; end
  def ruby_version_file; end
  def self.create(hash, path); end
  def signature; end
  def smart_loaded_path; end
  def target_rails_version; end
  def target_rails_version_from_bundler_lock_file; end
  def target_ruby_source; end
  def target_ruby_version; end
  def target_ruby_version_from_bundler_lock_file; end
  def target_ruby_version_from_version_file; end
  def to_h; end
  def to_hash; end
  def to_s; end
  def validate; end
  def validate_enforced_styles(valid_cop_names); end
  def validate_parameter_names(valid_cop_names); end
  def validate_section_presence(name); end
  def validate_support_and_has_list(name, formats, valid); end
  def validate_syntax_cop; end
  def warn_about_unrecognized_cops(invalid_cop_names); end
  include RuboCop::FileFinder
  include RuboCop::PathUtil
end
class RuboCop::ConfigLoaderResolver
  def base_configs(path, inherit_from, file); end
  def determine_inherit_mode(hash, key); end
  def duplicate_setting?(base_hash, derived_hash, key, inherited_file); end
  def gem_config_path(gem_name, relative_config_path); end
  def handle_disabled_by_default(config, new_default_configuration); end
  def inherited_file(path, inherit_from, file); end
  def initialize; end
  def merge(base_hash, derived_hash, **opts); end
  def merge_with_default(config, config_file, unset_nil:); end
  def remote_file?(uri); end
  def required_features; end
  def resolve_inheritance(path, hash, file, debug); end
  def resolve_inheritance_from_gems(hash, gems); end
  def resolve_requires(path, hash); end
  def should_union?(base_hash, key, inherit_mode); end
  def transform(config); end
  def warn_on_duplicate_setting(base_hash, derived_hash, key, **opts); end
end
class RuboCop::ConfigNotFoundError < RuboCop::Error
end
class RuboCop::ConfigLoader
  def self.add_excludes_from_files(config, config_file); end
  def self.add_inheritance_from_auto_generated_file; end
  def self.add_missing_namespaces(path, hash); end
  def self.auto_gen_config; end
  def self.auto_gen_config=(arg0); end
  def self.auto_gen_config?; end
  def self.check_duplication(yaml_code, absolute_path); end
  def self.clear_options; end
  def self.configuration_file_for(target_dir); end
  def self.configuration_from_file(config_file); end
  def self.debug; end
  def self.debug=(arg0); end
  def self.debug?; end
  def self.default_configuration; end
  def self.default_configuration=(arg0); end
  def self.existing_configuration(config_file); end
  def self.expand_path(path); end
  def self.find_project_dotfile(target_dir); end
  def self.find_user_dotfile; end
  def self.find_user_xdg_config; end
  def self.ignore_parent_exclusion; end
  def self.ignore_parent_exclusion=(arg0); end
  def self.ignore_parent_exclusion?; end
  def self.load_file(file); end
  def self.load_yaml_configuration(absolute_path); end
  def self.merge(base_hash, derived_hash); end
  def self.merge_with_default(config, config_file, unset_nil: nil); end
  def self.options_config; end
  def self.options_config=(arg0); end
  def self.read_file(absolute_path); end
  def self.required_features; end
  def self.resolver; end
  def self.write_config_file(file_name, file_string, rubocop_yml_contents); end
  def self.yaml_safe_load(yaml_code, filename); end
end
class RuboCop::ConfigStore
  def for(file_or_dir); end
  def force_default_config!; end
  def initialize; end
  def options_config=(options_config); end
end
class RuboCop::TargetFinder
  def all_cops_include; end
  def configured_include?(file); end
  def debug?; end
  def excluded_dirs(base_dir); end
  def fail_fast?; end
  def find(args); end
  def find_files(base_dir, flags); end
  def force_exclusion?; end
  def included_file?(file); end
  def initialize(config_store, options = nil); end
  def process_explicit_path(path); end
  def ruby_executable?(file); end
  def ruby_extension?(file); end
  def ruby_extensions; end
  def ruby_file?(file); end
  def ruby_filename?(file); end
  def ruby_filenames; end
  def ruby_interpreters(file); end
  def stdin?; end
  def target_files_in_dir(base_dir = nil); end
  def to_inspect?(file, hidden_files, base_dir_config); end
  def toplevel_dirs(base_dir, flags); end
end
class RuboCop::Token
  def begin_pos; end
  def column; end
  def comma?; end
  def comment?; end
  def end?; end
  def end_pos; end
  def equal_sign?; end
  def initialize(pos, type, text); end
  def left_array_bracket?; end
  def left_brace?; end
  def left_bracket?; end
  def left_curly_brace?; end
  def left_parens?; end
  def left_ref_bracket?; end
  def line; end
  def pos; end
  def rescue_modifier?; end
  def right_bracket?; end
  def right_curly_brace?; end
  def right_parens?; end
  def self.from_parser_token(parser_token); end
  def semicolon?; end
  def space_after?; end
  def space_before?; end
  def text; end
  def to_s; end
  def type; end
end
class RuboCop::CommentConfig
  def all_cop_names; end
  def analyze; end
  def analyze_cop(analysis, disabled, line, single_line); end
  def analyze_disabled(analysis, line); end
  def analyze_rest(analysis, line); end
  def analyze_single_line(analysis, line, disabled); end
  def comment_only_line?(line_number); end
  def cop_disabled_line_ranges; end
  def cop_enabled_at_line?(cop, line_number); end
  def cop_line_ranges(analysis); end
  def directive_parts(comment); end
  def each_directive; end
  def each_mentioned_cop; end
  def enable_all?(comment); end
  def extra_enabled_comments; end
  def extra_enabled_comments_with_names(extras, names); end
  def handle_enable_all(names, extras, comment); end
  def handle_switch(cop_names, names, disabled, extras, comment); end
  def initialize(processed_source); end
  def non_comment_token_line_numbers; end
  def processed_source; end
  def qualified_cop_name(cop_name); end
end
class RuboCop::CommentConfig::CopAnalysis < Struct
  def line_ranges; end
  def line_ranges=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def start_line_number; end
  def start_line_number=(_); end
end
class RuboCop::MagicComment
  def any?; end
  def encoding_specified?; end
  def extract(pattern); end
  def frozen_string_literal; end
  def frozen_string_literal?; end
  def frozen_string_literal_specified?; end
  def initialize(comment); end
  def self.parse(comment); end
  def specified?(value); end
end
class RuboCop::MagicComment::EditorComment < RuboCop::MagicComment
  def match(keyword); end
  def tokens; end
end
class RuboCop::MagicComment::EmacsComment < RuboCop::MagicComment::EditorComment
  def encoding; end
  def extract_frozen_string_literal; end
end
class RuboCop::MagicComment::VimComment < RuboCop::MagicComment::EditorComment
  def encoding; end
  def frozen_string_literal; end
end
class RuboCop::MagicComment::SimpleComment < RuboCop::MagicComment
  def encoding; end
  def extract_frozen_string_literal; end
end
class RuboCop::ProcessedSource
  def [](*args); end
  def ast; end
  def ast_with_comments; end
  def blank?; end
  def buffer; end
  def checksum; end
  def comment_config; end
  def comment_lines; end
  def commented?(source_range); end
  def comments; end
  def comments_before_line(line); end
  def create_parser(ruby_version); end
  def diagnostics; end
  def disabled_line_ranges; end
  def each_comment; end
  def each_token; end
  def file_path; end
  def find_comment; end
  def find_token; end
  def following_line(token); end
  def initialize(source, ruby_version, path = nil); end
  def line_indentation(line_number); end
  def lines; end
  def parse(source, ruby_version); end
  def parser_class(ruby_version); end
  def parser_error; end
  def path; end
  def preceding_line(token); end
  def raw_source; end
  def ruby_version; end
  def self.from_file(path, ruby_version); end
  def start_with?(string); end
  def tokenize(parser); end
  def tokens; end
  def valid_syntax?; end
end
class RuboCop::ResultCache
  def any_symlink?(path); end
  def file_checksum(file, config_store); end
  def initialize(file, options, config_store, cache_root = nil); end
  def load; end
  def relevant_options_digest(options); end
  def rubocop_checksum; end
  def save(offenses); end
  def self.allow_symlinks_in_cache_location?(config_store); end
  def self.cache_root(config_store); end
  def self.cleanup(config_store, verbose, cache_root = nil); end
  def self.inhibit_cleanup; end
  def self.inhibit_cleanup=(arg0); end
  def self.remove_files(files, dirs, remove_count); end
  def self.remove_oldest_files(files, dirs, cache_root, verbose); end
  def self.requires_file_removal?(file_count, config_store); end
  def self.source_checksum; end
  def self.source_checksum=(arg0); end
  def symlink_protection_triggered?(path); end
  def valid?; end
end
class RuboCop::Runner
  def aborting=(arg0); end
  def aborting?; end
  def add_unneeded_disables(file, offenses, source); end
  def autocorrect_unneeded_disables(source, cop); end
  def cached_run?; end
  def check_for_infinite_loop(processed_source, offenses); end
  def check_for_unneeded_disables?(source); end
  def considered_failure?(offense); end
  def do_inspection_loop(file, processed_source); end
  def each_inspected_file(files); end
  def enable_rails_cops(config); end
  def errors; end
  def file_offense_cache(file); end
  def file_offenses(file); end
  def file_started(file); end
  def filter_cop_classes(cop_classes, config); end
  def filtered_run?; end
  def find_target_files(paths); end
  def formatter_set; end
  def get_processed_source(file); end
  def initialize(options, config_store); end
  def inspect_file(processed_source); end
  def inspect_files(files); end
  def iterate_until_no_changes(source, offenses); end
  def list_files(paths); end
  def minimum_severity_to_fail; end
  def mobilized_cop_classes(config); end
  def process_file(file); end
  def run(paths); end
  def save_in_cache(cache, offenses); end
  def style_guide_cops_only?(config); end
  def warm_cache(target_files); end
  def warnings; end
end
class RuboCop::Runner::InfiniteCorrectionLoop < RuntimeError
  def initialize(path, offenses); end
  def offenses; end
end
class RuboCop::CLI
  def act_on_options; end
  def apply_default_formatter; end
  def config_lines(cop); end
  def config_store; end
  def cops_of_department(cops, department); end
  def display_error_summary(errors); end
  def display_warning_summary(warnings); end
  def execute_runner(paths); end
  def execute_runners(paths); end
  def handle_exiting_options; end
  def init_dotfile; end
  def initialize; end
  def line_length_cop(config); end
  def line_length_enabled?(config); end
  def max_line_length(config); end
  def maybe_print_corrected_source; end
  def maybe_run_line_length_cop(paths); end
  def options; end
  def print_available_cops; end
  def print_cop_details(cops); end
  def print_cops_of_department(registry, department, show_all); end
  def reset_config_and_auto_gen_file; end
  def run(args = nil); end
  def run_all_cops_auto_gen_config(line_length_contents, paths); end
  def run_line_length_cop_auto_gen_config(paths); end
  def same_max_line_length?(config1, config2); end
  def selected_cops_of_department(cops, department); end
  def validate_options_vs_config; end
  include RuboCop::Formatter::TextUtil
end
class RuboCop::CLI::Finished < RuntimeError
end
class RuboCop::IncorrectCopNameError < StandardError
end
class RuboCop::OptionArgumentError < StandardError
end
class RuboCop::Options
  def add_aliases(opts); end
  def add_auto_gen_options(opts); end
  def add_boolean_flags(opts); end
  def add_configuration_options(opts); end
  def add_cop_selection_csv_option(option, opts); end
  def add_flags_with_optional_args(opts); end
  def add_formatting_options(opts); end
  def add_list_options(opts); end
  def add_only_options(opts); end
  def add_severity_option(opts); end
  def args_from_env; end
  def args_from_file; end
  def define_options; end
  def initialize; end
  def long_opt_symbol(args); end
  def option(opts, *args); end
  def parse(command_line_args); end
end
class RuboCop::OptionsValidator
  def boolean_or_empty_cache?; end
  def display_only_fail_level_offenses_with_autocorrect?; end
  def except_syntax?; end
  def incompatible_options; end
  def initialize(options); end
  def only_includes_unneeded_disable?; end
  def self.format_message_from(name, cop_names); end
  def self.validate_cop_list(names); end
  def validate_auto_gen_config; end
  def validate_compatibility; end
  def validate_exclude_limit_option; end
  def validate_parallel; end
  def validate_parallel_with_combo_option; end
end
module RuboCop::OptionsHelp
end
class RuboCop::RemoteConfig
  def cache_name_from_uri; end
  def cache_path; end
  def cache_path_exists?; end
  def cache_path_expired?; end
  def file; end
  def generate_request(uri); end
  def handle_response(response, limit, &block); end
  def inherit_from_remote(file, path); end
  def initialize(url, base_dir); end
  def request(uri = nil, limit = nil, &block); end
  def uri; end
end
module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
  def self.traverse(tree, &on_duplicated); end
end
